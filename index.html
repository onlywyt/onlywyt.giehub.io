<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Liberte blog</title>

  
  <meta name="author" content="Liberte">
  

  

  
  <meta name="keywords" content="Java,Spring,Notes">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Liberte blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Liberte blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Liberte blog</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/search">搜索</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/blog/429901474.html"><span>我们都应该读读《生活与命运》</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/429901474.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-09-02T14:04:18.000Z">
          2023-09-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/S6vUVUj30LkPP7OiaiauwLZtkpbIgwwWo749cshxQwNer57bhYQR1wLaeyuKYzl3nGHABzBQq6fL9w0uFHH0z9uA/640?wx_fmt=png" alt="img"></p>
<p>这本书刚到，我一动不动看了200页。眼珠子都快看瞎了还是舍不得合上它。</p>
<p>书里梁文道的序：1961年2月14日上午，苏联国家安全委员会的特务闯进来格罗斯曼的家，为的是“搜捕”一份书稿。结果他们不只是带走了书、相关笔记和草稿，甚至连打出这本书的打字机和碳纸都不放过，行动规格如同逮捕一个活人，只不过他们这次要逮捕的是一本书。</p>
<p>这实在是太令人印象深刻了。到底是一本什么样的作品会令当局如此的忌惮。</p>
<p>这本书我很早就听说过，没有读的原因很可笑——我看到俄罗斯那冗长奇怪变化多端的人名字就脑阔疼！</p>
<p>伟大的小说开头各有各的魅力。</p>
<p>“田野上雾气沉沉。顺着公路伸展开去的高压线上，闪烁着汽车车灯的反光。”</p>
<p>“在千百的俄罗斯农舍中，没有也不可能有两座完全一模一样的。凡是有生命的东西，都各有各的特性。”</p>
<p>书里的观点就是一个词——自由。生命在于自由。每个人都能过着自己想要的生活，而不是被迫过着被某些人设计好的生活。每个人都可以说自己想说的事，论自己想论的人，而不是脑袋里装着一个个禁词。</p>
<p>我们以前就经历过那样的日子——任何一句话都可能被揪住上纲上线的审问。我们为此受到了难以诉说的苦难。</p>
<p>现在都是21世纪了，”我“竟然不能成为“我”，“我”竟然不能有“独立”的脑袋。新时代，还是不喜欢有脑袋的人，他们有各种手段，恩威并施的将我们的脑袋拿走，把我们的脑袋换成他们的。让我们自己把自己的心拿出来，然后自己涂上属于他们的颜色。</p>
<p>读这本书的时候，我不自觉的会联想到自己。我就像一根草，虽然我有思想，但是我却是自然界最脆弱的东西。不仅仅经受不起狂风骤雨，就算是一条狗踏过来也能把我踩的头破血流甚至踩死。</p>
<p>我一直以为现在跟过去不一样了，高尚、真诚的人就应该像一颗颗闪烁的星星一样耀眼。但是我错了，现在还是跟原来一样——“真诚、善良的人都该死”。我原来一直幻想，这个世界会变的。变成那种——透明的、真诚的、鹿是鹿、马是马的时代。但是直到有一位像导师一样的人说——被折磨惨的都是读书人…..我才知道…..</p>
<p>最后，</p>
<p>这本书的腰封上竟然写着“当代的战争与和平”。这真的是太令人惊讶了。我要争取快点读完，然后再读一遍。</p>
<p>祝大家周末愉快</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/读书笔记/">读书笔记</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/2949411629.html"><span>学习 SHELL</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/2949411629.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-09-02T13:23:59.000Z">
          2023-09-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <ol>
<li>编写一个命令，它可以递归地查找文件夹中所有的HTML文件，并将它们压缩成zip文件。注意，即使文件名中包含空格，您的命令也应该能够正确执行</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.html&quot;</span> | xargs -d <span class="string">&#x27;\n&#x27;</span> -I&#123;&#125; zip html_files.zip &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写两个bash函数 <code>marco</code> 和 <code>polo</code> 执行下面的操作。 每当你执行 <code>marco</code> 时，当前的工作目录应当以某种形式保存，当执行 <code>polo</code> 时，无论现在处在什么目录下，都应当 <code>cd</code> 回到当时执行 <code>marco</code> 的目录。 为了方便debug，你可以把代码写在单独的文件 <code>marco.sh</code> 中，并通过 <code>source marco.sh</code>命令，（重新）加载函数。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存当前工作目录</span></span><br><span class="line"><span class="function"><span class="title">marco</span></span>() &#123;</span><br><span class="line">	<span class="built_in">export</span> MARCO_DIR=$(<span class="built_in">pwd</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回到 marco 保存的目录</span></span><br><span class="line"><span class="function"><span class="title">polo</span></span>() &#123;</span><br><span class="line">	<span class="built_in">cd</span> <span class="variable">$MARCO_DIR</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 1.首先运行source marco.sh,然后在当前目录运行marco</span></span><br><span class="line"><span class="comment"># 2.cd 到任意目录，运行polo,就会返回到当时执行 `marco` 的目录</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/image-20230902212716936.png" alt="image-20230902212716936"></p>
<ol start="3">
<li>编写一个命令或脚本递归的查找文件夹中最近使用的文件。更通用的做法，你可以按照最近的使用时间列出文件吗？</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span>=<span class="variable">$1</span> <span class="comment"># m-modified时间 a-访问时间</span></span><br><span class="line"></span><br><span class="line">find . -<span class="built_in">type</span> f -print0 | xargs -0 <span class="built_in">stat</span> -f <span class="string">&#x27;%$&#123;type&#125;%t%S$&#123;type&#125; %N&#x27;</span> | <span class="built_in">sort</span> -nr</span><br></pre></td></tr></table></figure>


      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/1443152254.html"><span>我有自己的想法，我该死吗？</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/1443152254.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-30T13:48:30.000Z">
          2023-08-30
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>日本宣布开始排放福岛第一核电站因为2011年核事故而产生的核污水之后，我国再一次掀起了抢盐的风潮。我印象里最早一次国民级别的抢盐大战是在“非典时期”。</p>
<p>2003年无论是卖什么的小贩，都做起了食盐生意，并且很快从抢购食盐扩展到大米、食用油、调味品。为什么要疯狂的囤积食盐和一切与食盐有关的东西呢？</p>
<p>答案是当年的“非典型肺炎”让民众误以为是与“加碘盐”有关系。因此才疯狂的抢购。</p>
<p>那如今都2023年了，为什么还要抢盐呢？答案就是下面这幅图</p>
<p><img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/image-20230830221438327.png" alt="image-20230830221438327"></p>
<p>不知道是从哪儿流传出来的；碘片可以预防核辐射。</p>
<p>那么真相究竟是什么呢？</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/一个人/">一个人</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/1115468404.html"><span>Java CompletableFuture Demo</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/1115468404.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-28T11:56:18.000Z">
          2023-08-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h2><p>When working with asynchronous operations with Java,the CompletableFuture class offers a way to manage these operations in a more intuitive and structured manner.Two commonly used methods in this class for handling multiple asynchronous tasks are <code>allOf()</code>and <code>join()</code>.In the artcle,we will study these two methods.</p>
<h2 id="2-Combining-Multiple-CompletableFuture"><a href="#2-Combining-Multiple-CompletableFuture" class="headerlink" title="2.Combining Multiple CompletableFuture"></a>2.Combining Multiple CompletableFuture</h2><h3 id="2-1-Useing-CompletableFuture-allOf-join"><a href="#2-1-Useing-CompletableFuture-allOf-join" class="headerlink" title="2.1 Useing CompletableFuture.allOf().join()"></a>2.1 Useing CompletableFuture.allOf().join()</h3><p>The <code>allOf()</code>methods in CompletableFuture allows you to combine multiple asynchronous tasks and create a new CompletableFuture that completes when all of the input futures are completed.The <code>join()</code> methods is then used to block the current thread until all the input futures are completed.This is particularly useful when you have a collection of tasks that need to executed concurrently,and you want to wait for all of then to complete before proceeding.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">allOfDemo</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//是用CompletableFuture的allOf方法实现一个例子</span></span><br><span class="line">  CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="number">5</span>);</span><br><span class="line">  CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="number">10</span>);</span><br><span class="line">  <span class="comment">//join方法用来阻塞当前线程，等待future1 future2 计算完成</span></span><br><span class="line">  CompletableFuture.allOf(future1, future2).join();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> future1.get();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> future2.get();</span><br><span class="line">    System.out.println(<span class="string">&quot;result1: &quot;</span> + (integer));</span><br><span class="line">    System.out.println(<span class="string">&quot;result2: &quot;</span> + (integer1));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-Useing-CompletableFuture-allOf-join-with-multithreading"><a href="#2-2-Useing-CompletableFuture-allOf-join-with-multithreading" class="headerlink" title="2.2 Useing CompletableFuture.allOf().join() with multithreading"></a>2.2 Useing CompletableFuture.allOf().join() with multithreading</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">allDemoThread</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">ExecutorService</span> <span class="variable">executor1</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">  <span class="type">ExecutorService</span> <span class="variable">executor2</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">  CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">3000</span>); <span class="comment">// 休眠3秒</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">  &#125;, executor1);</span><br><span class="line"></span><br><span class="line">  CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">3000</span>); <span class="comment">// 休眠3秒</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;, executor2);</span><br><span class="line"></span><br><span class="line">  CompletableFuture.allOf(future1, future2).join();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> future1.get();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> future2.get();</span><br><span class="line">    System.out.println(<span class="string">&quot;result1: &quot;</span> + (integer));</span><br><span class="line">    System.out.println(<span class="string">&quot;result2: &quot;</span> + (integer1));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    executor1.shutdown();</span><br><span class="line">    executor2.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-Using-CompletableFuture-join"><a href="#2-3-Using-CompletableFuture-join" class="headerlink" title="2.3 Using CompletableFuture.join()"></a>2.3 Using CompletableFuture.join()</h2><p>On the other hand, the <code>join()</code> method on a single <code>CompletableFuture</code> is used to block the current thread and retrieve the result when the future is completed. This is useful when you have a single task that you want to wait for and obtain the result from. It’s important to note that unlike <code>allOf()</code>, <code>join()</code> is not used for combining multiple futures but for waiting on a single future.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="number">42</span>);</span><br><span class="line">   <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> future.join();</span><br><span class="line">   System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a>Error Handling</h2><h3 id="3-1-Handling-Exceptions-in-CompletableFuture-allOf-join"><a href="#3-1-Handling-Exceptions-in-CompletableFuture-allOf-join" class="headerlink" title="3.1 Handling Exceptions in CompletableFuture.allOf().join()"></a>3.1 Handling Exceptions in CompletableFuture.allOf().join()</h3><p>When using <code>CompletableFuture.allOf().join()</code>, exceptions that occur in any of the input futures are not directly propagated to the calling thread. Instead, the exceptions are typically stored within the individual futures. To handle exceptions in this scenario, you’ll need to retrieve them from the completed futures.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">AllOfErrorHandlerDemo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//处理CompletableFuture.allOf().join()中的异常,使用CompletableFuture.allOf().join()方法等待所有的CompletableFuture完成</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="number">5</span>)</span><br><span class="line">                .exceptionally(ex -&gt; &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;Exception in future1: &quot;</span> + ex);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Default value or recovery logic</span></span><br><span class="line">                &#125;);</span><br><span class="line">        CompletableFuture&lt;Object&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Something went wrong&quot;</span>);</span><br><span class="line">        &#125;).exceptionally(ex -&gt; &#123;</span><br><span class="line">            <span class="comment">//异常处理</span></span><br><span class="line">            System.err.println(<span class="string">&quot;Exception in future2: &quot;</span> + ex);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 返回一个新的CompletableFuture，当所有的CompletableFuture都完成后，新的CompletableFuture完成</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; combinedFuture = CompletableFuture.allOf(future1, future2);</span><br><span class="line">        <span class="comment">// join()方法等待future1和future2完成，然后打印结果</span></span><br><span class="line">        combinedFuture.join();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result1</span> <span class="operator">=</span> future1.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> (<span class="type">int</span>) future2.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;Result 1: &quot;</span> + result1);</span><br><span class="line">            System.out.println(<span class="string">&quot;Result 2: &quot;</span> + result2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>In this example, we’re using the <code>.exceptionally()</code> method to handle exceptions for each individual future. This allows us to log the exception and provide a default value or recovery logic if needed.</p>
<h2 id="4-Conclusion"><a href="#4-Conclusion" class="headerlink" title="4 Conclusion"></a>4 Conclusion</h2><p>In conclusion,both <code>CompletableFuture.allOf().join()</code> and <code>CompletableFuture.join()</code> are valuable tools in the asynchronous programming toolkit. They serve different purposes: <code>allOf().join()</code> is for combining multiple futures and waiting for their completion, while <code>join()</code> is for waiting on a single future. Understanding their use cases, behavior, and performance implications can greatly enhance your ability to write efficient and responsive asynchronous code in Java.</p>
<p>Java CompletableFuture Demo</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Java/">Java</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/4133792178.html"><span>RSA加密算法中的公钥和密钥</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/4133792178.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-26T15:38:31.000Z">
          2023-08-26
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="密钥对"><a href="#密钥对" class="headerlink" title="密钥对"></a>密钥对</h2><p>在昨天的文章<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/gItGxsGYi0SH5h237awSS">RSA加密算法</a>中提到了两个关键词——公钥、私钥。并且我们知道了，RSA 的加密就是求“明文的E次方 mod N”，解密是求“密文的D次方 mod N”。那么公式中的E、D、N这三个数就是<strong>生成的密钥对</strong>。</p>
<p>这三个数字肯定不是随随便便就拿来用的，那样的话加密也太容易被破解了。它们有自己的生成方式。</p>
<h2 id="RSA密钥对的生成"><a href="#RSA密钥对的生成" class="headerlink" title="RSA密钥对的生成"></a>RSA密钥对的生成</h2><p>我们先来简单陈述一下RSA密钥对的生成步骤，这其中涉及到了一些数学原理，暂时先不用知道什么意思。因为我也一知半解</p>
<ol>
<li>选择两个大的随机的质数 p 和 q</li>
<li>p 和 q进行乘法运算得到的值就是 N，这个N 就是公钥和私钥mod的那个N</li>
<li>计算 φ(n)， φ(n)= (p-1)*(q-1),其中φ是<strong>欧拉函数</strong>。暂时先不用知道什么是欧拉函数</li>
<li>现在来计算E，E 的计算规则是大于1但是小于 φ(n) 并且与 φ(n)<strong>互为质数</strong>。这个E就是公钥中的次幂数，暂时先不用知道什么是质数</li>
<li>现在来计算D，我们现在已经计算出来了公钥，E 和 N，那么D的计算规则需要满足以下条件：**(E * D) % φ(N) = 1**。为什么非要满足这个公式呢？因为只要数字D满足上述条件，通过E 和 N 进行加密的数据就可以通过D 和 N 进行解密</li>
</ol>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/密码技术-读书笔记/">密码技术,读书笔记</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/1463216031.html"><span>图解密码技术——RSA 公钥密码算法</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/1463216031.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-20T12:57:46.000Z">
          2023-08-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="公钥密码"><a href="#公钥密码" class="headerlink" title="公钥密码"></a>公钥密码</h2><p>公钥密码（Public-key cryptography）也称为非对称密码。是一种基于密钥对的密码体制。他需要两个密钥：公开密钥（public key ）和私有密钥（private key）。一般使用公钥加密，私钥解密。</p>
<h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><h3 id="什么是-RSA-？"><a href="#什么是-RSA-？" class="headerlink" title="什么是 RSA ？"></a>什么是 RSA ？</h3><p>RSA 是一种公钥密码算法，是目前使用最广泛的公钥密码算法。RSA 三个字母的含义是：它的三位发明者的姓氏首字母——</p>
<p>Ron Rivest、Adi Shamir 和 Leonard Adleman（Rivest Shamir Adleman）。</p>
<blockquote>
<p>在详细介绍 RSA 之前，需要先普及一点数学知识。</p>
</blockquote>
<h3 id="取模（余数）"><a href="#取模（余数）" class="headerlink" title="取模（余数）"></a>取模（余数）</h3><p>我们知道在编程语言中有<strong>取模运算</strong>，取模运算就是求余数的运算。例如：</p>
<p>我们要计算 12 除以 5 的余数，运算过程为：</p>
<ol>
<li> 12  中有几个 5？答案是 2 个。因为 5 * 2 = 10, 5 * 3 = 15 。所以 12  中只包含 2 个 5</li>
<li>那么两个 5 相乘不够 12 ，还差多少呢？12 - 10  = 2，这个 2 就是余数。</li>
<li>那么上述过程用Java 编程语言表示就是：<code>System.out.println(12 % 5); </code></li>
<li>这是简单的取模运算，那么我在来搞的复杂一点，12  这个数字可以分解为 2 * 2 * 2 * 2，也就是 2<sup>4</sup></li>
<li>我们来写一次取模的运算 2<sup>4</sup> mod 5</li>
</ol>
<p>我们简单回顾了十几二十年前的知识，如果你理解了上面的过程那么你就已经为详细学习 RSA 打好了基础，<strong>因为 RSA 的加密解密过程所进行的就是上述运算</strong></p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/密码技术-读书笔记/">密码技术,读书笔记</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/330343654.html"><span>《美国四百年》——师夷长技</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/330343654.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-20T12:26:00.000Z">
          2023-08-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>首先夸一下理想国。书本的装帧设计和印刷质量是真的好，捧在手里是真的有质感。</p>
<hr>
<p>之前一段时间看了一点《<a target="_blank" rel="noopener" href="https://www.books.com.tw/products/0010960415">獨立宣言：一部全球史</a>》。书里介绍，从全球的视角从新审视独立宣言，举世闻名的《独立宣言》不仅仅是美国的立国文书，更为现代世界的文明立下了文明的基础。对世界各地造成了巨大的影响。如今在看这本《美国四百年》更是感触颇深。美国是世界上最强大，最文明的国家之一。美国的《独立宣言》更是被视为国家财富，宣言中的人生而平等、人被赋予了生命权、自由权和追求幸福的权利….每一个字都透着美国特有的光彩。</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/读书笔记/">读书笔记</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/2785195764.html"><span>图解密码技术-CTR模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/2785195764.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-16T14:07:51.000Z">
          2023-08-16
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="常见的分组密码以及特点"><a href="#常见的分组密码以及特点" class="headerlink" title="常见的分组密码以及特点"></a>常见的分组密码以及特点</h2><p>常见的分组密码有DES、AES、SM4、Blowfish等。</p>
<p>分组密码的特点</p>
<ol>
<li>分组长度固定，常见的块长度有64位、128位、256位等</li>
<li>可以将数据进行分组，切割为不同的数据块，每一块数据单独处理加密</li>
<li>使用对称密钥，加解密使用的是同一个密钥</li>
<li>加解密算法是确定的，相同的明文、密钥和加密算法会产生相同的密文</li>
</ol>
<h2 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h2>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/密码技术-读书笔记/">密码技术,读书笔记</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/3573874495.html"><span>图解密码技术-对CFB模式的攻击</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/3573874495.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-14T14:40:07.000Z">
          2023-08-14
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="CFB模式简介"><a href="#CFB模式简介" class="headerlink" title="CFB模式简介"></a>CFB模式简介</h2><p>CFB模式全称是（Cipher FeedBack）<strong>密文反馈模式</strong>。加密方式是前一个密文分组会被送回到密码算法的输入端。简单理解就是，前一个密文分组在此加密后会当作下一次与明文异或运算的一部分，依次类推。如图：</p>
<img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/image-20230810223911494.png" alt="image-20230810223911494" style="zoom:100%;" />

<h2 id="CFB模式的解密"><a href="#CFB模式的解密" class="headerlink" title="CFB模式的解密"></a>CFB模式的解密</h2><p>因为CFB模式的加密利用了前一个密文分组，则解密的核心思路就是利用前一个明文分组的加密结果和当前密文进行异或运算得到当前明文。</p>
<h3 id="文字步骤如下："><a href="#文字步骤如下：" class="headerlink" title="文字步骤如下："></a>文字步骤如下：</h3><ol>
<li>解密端获得密文块C1、C2、C3…以及一个初始向量IV。</li>
<li>将IV进行加密,获得第一个密钥块K1。(使用的密钥和加密算法与加密端相同)</li>
<li>将密钥块K1与密文块C1进行异或,得到明文块P1。</li>
<li>将刚刚解密得到的明文块P1再次进行加密,生成下一个密钥块K2。</li>
<li>将K2与下一个密文块C2进行异或,得到明文块P2。</li>
<li>依此类推,重复步骤4和5,直到所有密文全部解密。</li>
</ol>
<h3 id="图示："><a href="#图示：" class="headerlink" title="图示："></a>图示：</h3><img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/image-20230814225641064.png" alt="image-20230814225641064" style="zoom:100%;" />

<h2 id="CFB模式的攻击"><a href="#CFB模式的攻击" class="headerlink" title="CFB模式的攻击"></a>CFB模式的攻击</h2><p>书中提到了一种攻击方式是<strong>重放攻击。</strong>（replay attack）</p>
<p>加入小美发送了一条信息，这条信息由4个密文组成。主动攻击者小明将消息的后3个密文分组保存下来，等第二天小美使用相同密钥再一次发送新消息的时候（新消息由4个新的密文组成）。小明就可以将昨天保存的密文分组进行替换。那么在解密的时候就会得到错误的信息。在真实的网络环境中，服务器与服务器之间的对话如果被攻击者利用进行重新发送或者延迟发送数据就会达到欺骗用户的目的。</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/密码技术-读书笔记/">密码技术,读书笔记</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/427224952.html"><span>图解密码技术-OFB模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/427224952.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-11T15:02:01.000Z">
          2023-08-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="常见的分组密码以及特点"><a href="#常见的分组密码以及特点" class="headerlink" title="常见的分组密码以及特点"></a>常见的分组密码以及特点</h2><p>常见的分组密码有DES、AES、SM4、Blowfish等。</p>
<p>分组密码的特点</p>
<ol>
<li><p>分组长度固定，常见的块长度有64位、128位、256位等</p>
</li>
<li><p>可以将数据进行分组，切割为不同的数据块，每一块数据单独处理加密</p>
</li>
<li><p>使用对称密钥，加解密使用的是同一个密钥</p>
</li>
<li><p>加解密算法是确定的，相同的明文、密钥和加密算法会产生相同的密文</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/密码技术-读书笔记/">密码技术,读书笔记</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2023 Liberte
    
  </p>
本站总访问量<span id="busuanzi_value_site_pv"></span>次
</footer>
    
    
  </div>
</div>
</body>
</html>