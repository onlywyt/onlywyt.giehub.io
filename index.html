<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Liberte blog</title>

  
  <meta name="author" content="Liberte">
  

  

  
  <meta name="keywords" content="Java,Spring,Notes">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Liberte blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Liberte blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Liberte blog</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/search">搜索</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/blog/1443152254.html"><span>我有自己的想法，我该死吗？</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/1443152254.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-30T13:48:30.000Z">
          2023-08-30
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>日本宣布开始排放福岛第一核电站因为2011年核事故而产生的核污水之后，我国再一次掀起了抢盐的风潮。我印象里最早一次国民级别的抢盐大战是在“非典时期”。</p>
<p>2003年无论是卖什么的小贩，都做起了食盐生意，并且很快从抢购食盐扩展到大米、食用油、调味品。为什么要疯狂的囤积食盐和一切与食盐有关的东西呢？</p>
<p>答案是当年的“非典型肺炎”让民众误以为是与“加碘盐”有关系。因此才疯狂的抢购。</p>
<p>那如今都2023年了，为什么还要抢盐呢？答案就是下面这幅图</p>
<p><img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/image-20230830221438327.png" alt="image-20230830221438327"></p>
<p>不知道是从哪儿流传出来的；碘片可以预防核辐射。</p>
<p>那么真相究竟是什么呢？</p>
<p>在生理学上，人体对碘的吸收是来自于甲状腺，甲状腺靠碘来产生甲状腺激素。KI是稳定性碘，它可以使甲状腺内的碘饱和从而阻止放射性碘的摄入。切尔诺贝利的经验表明，放射性碘是切尔诺贝利事故影响的主要因素。仔细阅读，针对的是放射性碘。</p>
<p>服用一片剂量的稳定碘可以在24小时内持续起到保护作用，主要是针对含有放射性碘同位素的辐射物质。</p>
<p>咱们来说回来盐。我过的加碘盐中的碘跟稳定碘片完全不是一个东西。碘盐中碘的存在形式是碘酸钾，主要是在人体肠胃以及血液中转换为碘离子被甲状腺吸收。我国规定碘盐的碘含量为30毫克/千克。按人均每天使用10克碘盐计算，可获得0.3毫克碘。而碘片碘的存在形式为碘化钾(KI)，碘含量为每片100毫克。按照每千克碘盐含30毫克碘计算，成人需要一次摄入碘盐约3千克，才能达到预防的效果。换句话说，就是我们天要吃6斤的盐，才能达到稳定碘片的含量的百分之九十。你敢想象吗？你每天喝水能喝六斤吗？</p>
<p>那大家为什么要抢盐呢？</p>
<p>我们往前想想，是不是不只是抢盐？我们是不是抢过大米？是不是抢过口罩？是不是抢过连花清瘟？</p>
<p><img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/image-20230830223447402.png" alt="image-20230830223447402"></p>
<p>我们国内正在掀起一轮新的反日狂潮。我非常能理解我们国内对与日本帝国主义的憎恨。正是因为如此我们要更加理智的去看待现在的日本，我们要明白现在的日本民众甚至日本政府跟以前的侵华日军是不一样的。我们带着憎恨的情绪去观察评论日本排放核污水这件事是很容易被仇恨拉低自己的智商进而做出不理智的判断。</p>
<p>我们可否还记得在过去的那三年里，日本政府和日本人民为我们捐赠了多少物资。我们可否还记得“山川异域，风月同天”、“岂曰无衣，与子同裳”这四句诗词。那时候他们和我们像是一家人。</p>
<p><img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/5e44daefe4b0c4aa59afdb27.jpeg" alt="5e44daefe4b0c4aa59afdb27"></p>
<p>因为福岛的核污水我们开始抵制日本的海鲜产品。但是最后有一些骨子里透着坏的人把矛头对准了自己的同胞。</p>
<p>8月24日，日本核污水排放首日晚上，多个中国渔民直播间出现大量不友好评论，有主播当场情绪崩溃表示：“到底还让不让我卖了！”也有渔民表示：“比每一个人心里边都难受，15年的努力在今天，一个时辰以内什么都没有了。”</p>
<p><img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/482982f17765489087582ddfa8499321-20230830224852971.jpeg" alt="img"></p>
<p>核污水的排放暂且不说是不是真的对海洋生物有影响，就算是真的有影响按照洋流的分布以及流向，首当其冲的是加拿大和美国。我们可以搜一下“日本暖流”，日本暖流是南北向的洋流，福岛排放的核污水会顺着日本暖流往西走，首先到达的地区是美国和加拿大。然后才会顺着太平洋一直到达我国沿海。</p>
<p>评论区的人明显没有想这么多。他们只顾着自己痛快。荒唐的评论，就如同地狱里的镰刀一样，把人性最卑劣的恶给勾勒出来，无辜的因他们的一句话而倾家荡产，真诚善良的人不得活。</p>
<p>但是在这种时候，如果你不选择做一个恶人，就得活在[汉奸、走狗]的恐惧中。</p>
<p>这股反日洪流在我身上碾过，我坚持自己。</p>
<p>这样一个巨大的帘子下。我知道很多人都不知道。</p>
<p>我一直都存幻想，成年人的世界里就是爱憎分明，就是非黑即白，钉是钉，卯是卯，鹿就是鹿，马就是马。我不能理解这个世界的荒诞，我想改变，但是有位老师说：最悲哀的莫过于读书人….</p>
<p>说回来福岛核污水。</p>
<p>我在网上查到了国际原子能机构启动新网站，提供有关福岛核电站处理水排放的实时数据。</p>
<ol>
<li>原子能机构于7月4日发布了关于对福岛第一核电站先进液体处理系统处理水的安全审查情况的综合报告。报告认为，日本采取的先进液体处理系统处理水排放方案和活动符合相关的国际安全标准。</li>
<li>原子能机构的独立现场分析证实，正在排放的处理水中的氚浓度远远低于每升1500贝克勒尔的操作限值。</li>
<li>除现场监测外，原子能机构还将通过持续的现场存在，在排放阶段继续进行安全审查，从而履行格罗西关于在排水之前、之中和之后都会参与其中的承诺。</li>
</ol>
<p>为了避免你说我吹牛逼洗日本，我把链接放在这：<a target="_blank" rel="noopener" href="https://news.un.org/zh/story/2023/08/1120892">https://news.un.org/zh/story/2023/08/1120892</a></p>
<p>好好生活吧，对自己身边的人好点，对自己好点。多关心关心身边人。日本离咱们太远了。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/一个人/">一个人</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/1115468404.html"><span>Java CompletableFuture Demo</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/1115468404.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-28T11:56:18.000Z">
          2023-08-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h2><p>When working with asynchronous operations with Java,the CompletableFuture class offers a way to manage these operations in a more intuitive and structured manner.Two commonly used methods in this class for handling multiple asynchronous tasks are <code>allOf()</code>and <code>join()</code>.In the artcle,we will study these two methods.</p>
<h2 id="2-Combining-Multiple-CompletableFuture"><a href="#2-Combining-Multiple-CompletableFuture" class="headerlink" title="2.Combining Multiple CompletableFuture"></a>2.Combining Multiple CompletableFuture</h2><h3 id="2-1-Useing-CompletableFuture-allOf-join"><a href="#2-1-Useing-CompletableFuture-allOf-join" class="headerlink" title="2.1 Useing CompletableFuture.allOf().join()"></a>2.1 Useing CompletableFuture.allOf().join()</h3><p>The <code>allOf()</code>methods in CompletableFuture allows you to combine multiple asynchronous tasks and create a new CompletableFuture that completes when all of the input futures are completed.The <code>join()</code> methods is then used to block the current thread until all the input futures are completed.This is particularly useful when you have a collection of tasks that need to executed concurrently,and you want to wait for all of then to complete before proceeding.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">allOfDemo</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//是用CompletableFuture的allOf方法实现一个例子</span></span><br><span class="line">  CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="number">5</span>);</span><br><span class="line">  CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="number">10</span>);</span><br><span class="line">  <span class="comment">//join方法用来阻塞当前线程，等待future1 future2 计算完成</span></span><br><span class="line">  CompletableFuture.allOf(future1, future2).join();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> future1.get();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> future2.get();</span><br><span class="line">    System.out.println(<span class="string">&quot;result1: &quot;</span> + (integer));</span><br><span class="line">    System.out.println(<span class="string">&quot;result2: &quot;</span> + (integer1));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-Useing-CompletableFuture-allOf-join-with-multithreading"><a href="#2-2-Useing-CompletableFuture-allOf-join-with-multithreading" class="headerlink" title="2.2 Useing CompletableFuture.allOf().join() with multithreading"></a>2.2 Useing CompletableFuture.allOf().join() with multithreading</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">allDemoThread</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">ExecutorService</span> <span class="variable">executor1</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">  <span class="type">ExecutorService</span> <span class="variable">executor2</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">  CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">3000</span>); <span class="comment">// 休眠3秒</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">  &#125;, executor1);</span><br><span class="line"></span><br><span class="line">  CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">3000</span>); <span class="comment">// 休眠3秒</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;, executor2);</span><br><span class="line"></span><br><span class="line">  CompletableFuture.allOf(future1, future2).join();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> future1.get();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> future2.get();</span><br><span class="line">    System.out.println(<span class="string">&quot;result1: &quot;</span> + (integer));</span><br><span class="line">    System.out.println(<span class="string">&quot;result2: &quot;</span> + (integer1));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    executor1.shutdown();</span><br><span class="line">    executor2.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-Using-CompletableFuture-join"><a href="#2-3-Using-CompletableFuture-join" class="headerlink" title="2.3 Using CompletableFuture.join()"></a>2.3 Using CompletableFuture.join()</h2><p>On the other hand, the <code>join()</code> method on a single <code>CompletableFuture</code> is used to block the current thread and retrieve the result when the future is completed. This is useful when you have a single task that you want to wait for and obtain the result from. It’s important to note that unlike <code>allOf()</code>, <code>join()</code> is not used for combining multiple futures but for waiting on a single future.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="number">42</span>);</span><br><span class="line">   <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> future.join();</span><br><span class="line">   System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a>Error Handling</h2><h3 id="3-1-Handling-Exceptions-in-CompletableFuture-allOf-join"><a href="#3-1-Handling-Exceptions-in-CompletableFuture-allOf-join" class="headerlink" title="3.1 Handling Exceptions in CompletableFuture.allOf().join()"></a>3.1 Handling Exceptions in CompletableFuture.allOf().join()</h3><p>When using <code>CompletableFuture.allOf().join()</code>, exceptions that occur in any of the input futures are not directly propagated to the calling thread. Instead, the exceptions are typically stored within the individual futures. To handle exceptions in this scenario, you’ll need to retrieve them from the completed futures.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">AllOfErrorHandlerDemo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//处理CompletableFuture.allOf().join()中的异常,使用CompletableFuture.allOf().join()方法等待所有的CompletableFuture完成</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="number">5</span>)</span><br><span class="line">                .exceptionally(ex -&gt; &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;Exception in future1: &quot;</span> + ex);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Default value or recovery logic</span></span><br><span class="line">                &#125;);</span><br><span class="line">        CompletableFuture&lt;Object&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Something went wrong&quot;</span>);</span><br><span class="line">        &#125;).exceptionally(ex -&gt; &#123;</span><br><span class="line">            <span class="comment">//异常处理</span></span><br><span class="line">            System.err.println(<span class="string">&quot;Exception in future2: &quot;</span> + ex);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 返回一个新的CompletableFuture，当所有的CompletableFuture都完成后，新的CompletableFuture完成</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; combinedFuture = CompletableFuture.allOf(future1, future2);</span><br><span class="line">        <span class="comment">// join()方法等待future1和future2完成，然后打印结果</span></span><br><span class="line">        combinedFuture.join();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result1</span> <span class="operator">=</span> future1.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> (<span class="type">int</span>) future2.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;Result 1: &quot;</span> + result1);</span><br><span class="line">            System.out.println(<span class="string">&quot;Result 2: &quot;</span> + result2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>In this example, we’re using the <code>.exceptionally()</code> method to handle exceptions for each individual future. This allows us to log the exception and provide a default value or recovery logic if needed.</p>
<h2 id="4-Conclusion"><a href="#4-Conclusion" class="headerlink" title="4 Conclusion"></a>4 Conclusion</h2><p>In conclusion,both <code>CompletableFuture.allOf().join()</code> and <code>CompletableFuture.join()</code> are valuable tools in the asynchronous programming toolkit. They serve different purposes: <code>allOf().join()</code> is for combining multiple futures and waiting for their completion, while <code>join()</code> is for waiting on a single future. Understanding their use cases, behavior, and performance implications can greatly enhance your ability to write efficient and responsive asynchronous code in Java.</p>
<p>Java CompletableFuture Demo</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Java/">Java</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/4133792178.html"><span>RSA加密算法中的公钥和密钥</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/4133792178.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-26T15:38:31.000Z">
          2023-08-26
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="密钥对"><a href="#密钥对" class="headerlink" title="密钥对"></a>密钥对</h2><p>在昨天的文章<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/gItGxsGYi0SH5h237awSS">RSA加密算法</a>中提到了两个关键词——公钥、私钥。并且我们知道了，RSA 的加密就是求“明文的E次方 mod N”，解密是求“密文的D次方 mod N”。那么公式中的E、D、N这三个数就是<strong>生成的密钥对</strong>。</p>
<p>这三个数字肯定不是随随便便就拿来用的，那样的话加密也太容易被破解了。它们有自己的生成方式。</p>
<h2 id="RSA密钥对的生成"><a href="#RSA密钥对的生成" class="headerlink" title="RSA密钥对的生成"></a>RSA密钥对的生成</h2><p>我们先来简单陈述一下RSA密钥对的生成步骤，这其中涉及到了一些数学原理，暂时先不用知道什么意思。因为我也一知半解</p>
<ol>
<li>选择两个大的随机的质数 p 和 q</li>
<li>p 和 q进行乘法运算得到的值就是 N，这个N 就是公钥和私钥mod的那个N</li>
<li>计算 φ(n)， φ(n)= (p-1)*(q-1),其中φ是<strong>欧拉函数</strong>。暂时先不用知道什么是欧拉函数</li>
<li>现在来计算E，E 的计算规则是大于1但是小于 φ(n) 并且与 φ(n)<strong>互为质数</strong>。这个E就是公钥中的次幂数，暂时先不用知道什么是质数</li>
<li>现在来计算D，我们现在已经计算出来了公钥，E 和 N，那么D的计算规则需要满足以下条件：**(E * D) % φ(N) = 1**。为什么非要满足这个公式呢？因为只要数字D满足上述条件，通过E 和 N 进行加密的数据就可以通过D 和 N 进行解密</li>
</ol>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/密码技术-读书笔记/">密码技术,读书笔记</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/1463216031.html"><span>图解密码技术——RSA 公钥密码算法</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/1463216031.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-20T12:57:46.000Z">
          2023-08-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="公钥密码"><a href="#公钥密码" class="headerlink" title="公钥密码"></a>公钥密码</h2><p>公钥密码（Public-key cryptography）也称为非对称密码。是一种基于密钥对的密码体制。他需要两个密钥：公开密钥（public key ）和私有密钥（private key）。一般使用公钥加密，私钥解密。</p>
<h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><h3 id="什么是-RSA-？"><a href="#什么是-RSA-？" class="headerlink" title="什么是 RSA ？"></a>什么是 RSA ？</h3><p>RSA 是一种公钥密码算法，是目前使用最广泛的公钥密码算法。RSA 三个字母的含义是：它的三位发明者的姓氏首字母——</p>
<p>Ron Rivest、Adi Shamir 和 Leonard Adleman（Rivest Shamir Adleman）。</p>
<blockquote>
<p>在详细介绍 RSA 之前，需要先普及一点数学知识。</p>
</blockquote>
<h3 id="取模（余数）"><a href="#取模（余数）" class="headerlink" title="取模（余数）"></a>取模（余数）</h3><p>我们知道在编程语言中有<strong>取模运算</strong>，取模运算就是求余数的运算。例如：</p>
<p>我们要计算 12 除以 5 的余数，运算过程为：</p>
<ol>
<li> 12  中有几个 5？答案是 2 个。因为 5 * 2 = 10, 5 * 3 = 15 。所以 12  中只包含 2 个 5</li>
<li>那么两个 5 相乘不够 12 ，还差多少呢？12 - 10  = 2，这个 2 就是余数。</li>
<li>那么上述过程用Java 编程语言表示就是：<code>System.out.println(12 % 5); </code></li>
<li>这是简单的取模运算，那么我在来搞的复杂一点，12  这个数字可以分解为 2 * 2 * 2 * 2，也就是 2<sup>4</sup></li>
<li>我们来写一次取模的运算 2<sup>4</sup> mod 5</li>
</ol>
<p>我们简单回顾了十几二十年前的知识，如果你理解了上面的过程那么你就已经为详细学习 RSA 打好了基础，<strong>因为 RSA 的加密解密过程所进行的就是上述运算</strong></p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/密码技术-读书笔记/">密码技术,读书笔记</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/330343654.html"><span>《美国四百年》——师夷长技</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/330343654.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-20T12:26:00.000Z">
          2023-08-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>首先夸一下理想国。书本的装帧设计和印刷质量是真的好，捧在手里是真的有质感。</p>
<hr>
<p>之前一段时间看了一点《<a target="_blank" rel="noopener" href="https://www.books.com.tw/products/0010960415">獨立宣言：一部全球史</a>》。书里介绍，从全球的视角从新审视独立宣言，举世闻名的《独立宣言》不仅仅是美国的立国文书，更为现代世界的文明立下了文明的基础。对世界各地造成了巨大的影响。如今在看这本《美国四百年》更是感触颇深。美国是世界上最强大，最文明的国家之一。美国的《独立宣言》更是被视为国家财富，宣言中的人生而平等、人被赋予了生命权、自由权和追求幸福的权利….每一个字都透着美国特有的光彩。</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/读书笔记/">读书笔记</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/2785195764.html"><span>图解密码技术-CTR模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/2785195764.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-16T14:07:51.000Z">
          2023-08-16
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="常见的分组密码以及特点"><a href="#常见的分组密码以及特点" class="headerlink" title="常见的分组密码以及特点"></a>常见的分组密码以及特点</h2><p>常见的分组密码有DES、AES、SM4、Blowfish等。</p>
<p>分组密码的特点</p>
<ol>
<li>分组长度固定，常见的块长度有64位、128位、256位等</li>
<li>可以将数据进行分组，切割为不同的数据块，每一块数据单独处理加密</li>
<li>使用对称密钥，加解密使用的是同一个密钥</li>
<li>加解密算法是确定的，相同的明文、密钥和加密算法会产生相同的密文</li>
</ol>
<h2 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h2>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/密码技术-读书笔记/">密码技术,读书笔记</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/3573874495.html"><span>图解密码技术-对CFB模式的攻击</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/3573874495.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-14T14:40:07.000Z">
          2023-08-14
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="CFB模式简介"><a href="#CFB模式简介" class="headerlink" title="CFB模式简介"></a>CFB模式简介</h2><p>CFB模式全称是（Cipher FeedBack）<strong>密文反馈模式</strong>。加密方式是前一个密文分组会被送回到密码算法的输入端。简单理解就是，前一个密文分组在此加密后会当作下一次与明文异或运算的一部分，依次类推。如图：</p>
<img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/image-20230810223911494.png" alt="image-20230810223911494" style="zoom:100%;" />

<h2 id="CFB模式的解密"><a href="#CFB模式的解密" class="headerlink" title="CFB模式的解密"></a>CFB模式的解密</h2><p>因为CFB模式的加密利用了前一个密文分组，则解密的核心思路就是利用前一个明文分组的加密结果和当前密文进行异或运算得到当前明文。</p>
<h3 id="文字步骤如下："><a href="#文字步骤如下：" class="headerlink" title="文字步骤如下："></a>文字步骤如下：</h3><ol>
<li>解密端获得密文块C1、C2、C3…以及一个初始向量IV。</li>
<li>将IV进行加密,获得第一个密钥块K1。(使用的密钥和加密算法与加密端相同)</li>
<li>将密钥块K1与密文块C1进行异或,得到明文块P1。</li>
<li>将刚刚解密得到的明文块P1再次进行加密,生成下一个密钥块K2。</li>
<li>将K2与下一个密文块C2进行异或,得到明文块P2。</li>
<li>依此类推,重复步骤4和5,直到所有密文全部解密。</li>
</ol>
<h3 id="图示："><a href="#图示：" class="headerlink" title="图示："></a>图示：</h3><img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/image-20230814225641064.png" alt="image-20230814225641064" style="zoom:100%;" />

<h2 id="CFB模式的攻击"><a href="#CFB模式的攻击" class="headerlink" title="CFB模式的攻击"></a>CFB模式的攻击</h2><p>书中提到了一种攻击方式是<strong>重放攻击。</strong>（replay attack）</p>
<p>加入小美发送了一条信息，这条信息由4个密文组成。主动攻击者小明将消息的后3个密文分组保存下来，等第二天小美使用相同密钥再一次发送新消息的时候（新消息由4个新的密文组成）。小明就可以将昨天保存的密文分组进行替换。那么在解密的时候就会得到错误的信息。在真实的网络环境中，服务器与服务器之间的对话如果被攻击者利用进行重新发送或者延迟发送数据就会达到欺骗用户的目的。</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/密码技术-读书笔记/">密码技术,读书笔记</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/427224952.html"><span>图解密码技术-OFB模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/427224952.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-11T15:02:01.000Z">
          2023-08-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="常见的分组密码以及特点"><a href="#常见的分组密码以及特点" class="headerlink" title="常见的分组密码以及特点"></a>常见的分组密码以及特点</h2><p>常见的分组密码有DES、AES、SM4、Blowfish等。</p>
<p>分组密码的特点</p>
<ol>
<li><p>分组长度固定，常见的块长度有64位、128位、256位等</p>
</li>
<li><p>可以将数据进行分组，切割为不同的数据块，每一块数据单独处理加密</p>
</li>
<li><p>使用对称密钥，加解密使用的是同一个密钥</p>
</li>
<li><p>加解密算法是确定的，相同的明文、密钥和加密算法会产生相同的密文</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/密码技术-读书笔记/">密码技术,读书笔记</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/4282522732.html"><span>图解密码技术-CFB模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/4282522732.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-10T14:15:39.000Z">
          2023-08-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<blockquote>
<p>分组密码(Block Cipher)是一种密码对称加密算法，特点是按照固定长度的块(block)来对数据进行加密和解密。</p>
</blockquote>
</blockquote>
<h2 id="常见的分组密码以及特点"><a href="#常见的分组密码以及特点" class="headerlink" title="常见的分组密码以及特点"></a>常见的分组密码以及特点</h2><p>常见的分组密码有DES、AES、SM4、Blowfish等。</p>
<p>分组密码的特点</p>
<ol>
<li>分组长度固定，常见的块长度有64位、128位、256位等</li>
<li>可以将数据进行分组，切割为不同的数据块，每一块数据单独处理加密</li>
<li>使用对称密钥，加解密使用的是同一个密钥</li>
<li>加解密算法是确定的，相同的明文、密钥和加密算法会产生相同的密文</li>
</ol>
<h2 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h2><p>分组密码算法只能加密固定长度的分组，但是我们需要加密的明文可能会超过分组密码分组的长度，这时候就需要对明文进行切割，分成几组分别进行加密，直到所有的明文加密完成。这种方式就称之为分组密码的<strong>模式</strong>。</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/密码技术-读书笔记/">密码技术,读书笔记</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/3716094242.html"><span>图解密码技术-CBC模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/3716094242.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-09T14:27:33.000Z">
          2023-08-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>分组密码(Block Cipher)是一种密码对称加密算法，特点是按照固定长度的块(block)来对数据进行加密和解密。</p>
</blockquote>
<h2 id="常见的分组密码以及特点"><a href="#常见的分组密码以及特点" class="headerlink" title="常见的分组密码以及特点"></a>常见的分组密码以及特点</h2><p>常见的分组密码有DES、AES、SM4、Blowfish等。</p>
<p>分组密码的特点</p>
<ol>
<li>分组长度固定，常见的块长度有64位、128位、256位等</li>
<li>可以将数据进行分组，切割为不同的数据块，每一块数据单独处理加密</li>
<li>使用对称密钥，加解密使用的是同一个密钥</li>
<li>加解密算法是确定的，相同的明文、密钥和加密算法会产生相同的密文</li>
</ol>
<h2 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h2>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/密码技术-读书笔记/">密码技术,读书笔记</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2023 Liberte
    
  </p>
本站总访问量<span id="busuanzi_value_site_pv"></span>次
</footer>
    
    
  </div>
</div>
</body>
</html>