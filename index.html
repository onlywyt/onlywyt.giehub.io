<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Liberte blog</title>

  
  <meta name="author" content="Liberte">
  

  

  
  <meta name="keywords" content="Java,Spring,Notes">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Liberte blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Liberte blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Liberte blog</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/search">搜索</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/blog/1463216031.html"><span>图解密码技术——公钥密码</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/1463216031.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-20T12:57:46.000Z">
          2023-08-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/330343654.html"><span>《美国四百年》——师夷长技</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/330343654.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-20T12:26:51.000Z">
          2023-08-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>首先夸一下理想国。书本的装帧设计和印刷质量是真的好，捧在手里是真的有质感。</p>
<hr>
<p>之前一段时间看了一点《<a target="_blank" rel="noopener" href="https://www.books.com.tw/products/0010960415">獨立宣言：一部全球史</a>》。书里介绍，从全球的视角从新审视独立宣言，举世闻名的《独立宣言》不仅仅是美国的立国文书，更为现代世界的文明立下了文明的基础。对世界各地造成了巨大的影响。如今在看这本《美国四百年》更是感触颇深。美国是世界上最强大，最文明的国家之一。美国的《独立宣言》更是被视为国家财富，宣言中的人生而平等、人被赋予了生命权、自由权和追求幸福的权利….每一个字都透着美国特有的光彩。</p>
<p>《美国四百年》这本书从一开始就不断的强调民主、强调自由的社会环境可以带来无尽的创造力。</p>
<p>你说这本书是历史书但是它没有历史书那么枯燥，但是它几乎讲述了美国全部的历史。你说它是经济学著作，但是又比一般的经济学好读好懂。没有枯燥乏味的令人昏昏欲睡的经济学名词，但是整个美国历史上几乎所有的经济事件以及没一件发生的背后逻辑都讲述的清清楚楚。可读性极强。</p>
<p>相信大家都玩过消消乐，有的时候你随手连接的一个弹珠确导致了一大片的弹珠被消灭。细读书里有很多细节都想玩消消乐。</p>
<p>比如：李维斯牛仔裤的出现是淘金产品兴起的副产品，美国 IBM 的崛起是因为大洲之间要做人口普查，无线电报的普及应用是因为泰坦尼克号的事故….</p>
<p>我还没有读完这本书，但是挑选的几章就已经深深的吸引了我。美国现存的文明和物质是几百年来美国政治经济不断博弈、自由和保守不断碰撞互相制约的产物。</p>
<p>现在美帝国主义亡我之心不死，我们只有坚持师夷长技才能真正打败他们。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/读书笔记/">读书笔记</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/2785195764.html"><span>图解密码技术-CTR模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/2785195764.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-16T14:07:51.000Z">
          2023-08-16
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="常见的分组密码以及特点"><a href="#常见的分组密码以及特点" class="headerlink" title="常见的分组密码以及特点"></a>常见的分组密码以及特点</h2><p>常见的分组密码有DES、AES、SM4、Blowfish等。</p>
<p>分组密码的特点</p>
<ol>
<li>分组长度固定，常见的块长度有64位、128位、256位等</li>
<li>可以将数据进行分组，切割为不同的数据块，每一块数据单独处理加密</li>
<li>使用对称密钥，加解密使用的是同一个密钥</li>
<li>加解密算法是确定的，相同的明文、密钥和加密算法会产生相同的密文</li>
</ol>
<h2 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h2><p>分组密码算法只能加密固定长度的分组，但是我们需要加密的明文可能会超过分组密码分组的长度，这时候就需要对明文进行切割，分成几组分别进行加密，直到所有的明文加密完成。这种方式就称之为分组密码的<strong>模式</strong>。</p>
<h3 id="分组密码的主要模式"><a href="#分组密码的主要模式" class="headerlink" title="分组密码的主要模式"></a>分组密码的主要模式</h3><ol>
<li>ECB模式：(Electronic CodeBook mode) 电子密码本模式</li>
<li>CBC模式：(Cipher Block Chaining mode) 密码分组链接模式</li>
<li>CFB模式：(Cipher FeedBack mode) 密文反馈模式</li>
<li>OFB模式：(Output FeedBack mode)输出反馈模式</li>
<li>CTR模式：(CounTeR mode) 计数器模式</li>
</ol>
<p>今天来了解一下最后一个模式——CTR 模式</p>
<h2 id="CTR模式（CounTeR）计数器模式"><a href="#CTR模式（CounTeR）计数器模式" class="headerlink" title="CTR模式（CounTeR）计数器模式"></a>CTR模式（CounTeR）计数器模式</h2><p>顾名思义，CTR 模式是一种累加计数进行加密来生成密钥流的<strong>流密码</strong>。</p>
<h3 id="又提到了流密码"><a href="#又提到了流密码" class="headerlink" title="又提到了流密码"></a>又提到了流密码</h3><blockquote>
<p>在 CFB 模式中简单介绍过流密码：简单解释就是，加密的密钥流比喻为一个旋转门，我们需要加密的明文就像是一群人。这个旋转门每次只能过去一个人，当所有人一个个的通过旋转门的时候就会与当前旋转门进行一次异或运算。旋转门每一次转动都会产生一个不同的数字，这样当人通过的时候异或的结果也不一样。最终当所有人通过那么就会得到最后的加密之后的数据</p>
</blockquote>
<p>那么到底什么是逐次累加来生成密钥呢？如图所示：</p>
<p><img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/image-20230816221923742.png" alt="image-20230816221923742"></p>
<p>CTR 加密的具体步骤</p>
<ol>
<li>生成一个初始化计数器的值IV，其长度与明文长度一致。这个值必须是唯一的，一般情况下取值为可以递增的整数</li>
<li>将计数器初始值 IV 进行加密与明文分组 A 进行异或运算得到密文分组 A</li>
<li>然后计数器自增加密，然后与下一个明文分组异或得到下一组密文</li>
<li>以此类推，知道所有明文加密完成</li>
</ol>
<h2 id="关于计数器"><a href="#关于计数器" class="headerlink" title="关于计数器"></a>关于计数器</h2><p>我理解计数器就像一个唯一的序列号，至少对于每一组的明文来说是唯一的，计数器的长度应该与明文的长度保持一致，加入明文的长度是 128 位那么计数器的长度也应该是 128 位。计数器的初始值必须是随机的，每次加密新的明文都需要重新生成，如果使用相同的计数器则会面临<strong>重放攻击</strong>。<u>每个明文块对应一个计数器值,计数器需要逐块递增,不能重复也不能跳跃。</u></p>
<blockquote>
<p>​    <strong>CTR模式中每个明文块对应一个计数器值并逐块递增的主要原因有以下几点:</strong></p>
<ol>
<li>保证每次异或输入的唯一性。如果计数器重复或者跳跃,多个明文块会使用同一个计数器值进行异或,这会导致密文重复,降低安全强度。</li>
<li>避免相同明文块产生相同密文。如果计数器不递增,相同的明文块会产生完全相同的密文,这也会泄露明文信息。</li>
<li>简化并行计算。计数器逐块递增可以让每个明文块的计算相互独立,没有依赖关系,便于进行并行计算。</li>
<li>保证误差传播有限。即使中间有密文块丢失或损坏,也只会影响该块的解密,不会导致后续所有密文无法解密。</li>
<li>防止字节级别的明文操作。如果允许计数器跳跃,攻击者可以通过调整计数器对应明文中的字节,来操作明文内容。</li>
<li>符合CTR模式的设计理念。CTR模式实质上是将块密码转变为流密码,每次加密一个明文字节或位,所以计数器必须连续。</li>
</ol>
</blockquote>
<p><strong>上面的解释来自 ChatGPT</strong></p>
<h2 id="OFB-模式与-CTR-模式的对比"><a href="#OFB-模式与-CTR-模式的对比" class="headerlink" title="OFB 模式与 CTR 模式的对比"></a>OFB 模式与 CTR 模式的对比</h2><p>OFB和 CTR  模式都是属于<strong>流密码</strong>。CTR 模式使用计数器的值作为密钥流的输入而 OFB 模式使用加密的输出作为下一个密钥流的输入。加密过程如下图：</p>
<p><img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/image-20230816232109495.png" alt="image-20230816232109495"></p>
<h2 id="Java-语言实现-CTR-模式加解密"><a href="#Java-语言实现-CTR-模式加解密" class="headerlink" title="Java 语言实现 CTR 模式加解密"></a>Java 语言实现 CTR 模式加解密</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yt.mvcframework.v2.CTRDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.IvParameterSpec;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CTRExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 生成 AES 密钥</span></span><br><span class="line">        <span class="type">KeyGenerator</span> <span class="variable">kg</span> <span class="operator">=</span> KeyGenerator.getInstance(<span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">key</span> <span class="operator">=</span> kg.generateKey();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 SecureRandom 生成随机 IV，长度为 16 字节</span></span><br><span class="line">        <span class="type">byte</span>[] ivBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>];</span><br><span class="line">        SecureRandom.getInstanceStrong().nextBytes(ivBytes);</span><br><span class="line">        <span class="type">IvParameterSpec</span> <span class="variable">iv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(ivBytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化用于加密的 Cipher 实例，使用 AES/CTR/PKCS5Padding 模式</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">encipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/CTR/PKCS5Padding&quot;</span>);</span><br><span class="line">        encipher.init(Cipher.ENCRYPT_MODE, key, iv);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加密明文</span></span><br><span class="line">        <span class="type">byte</span>[] plaintext = <span class="string">&quot;Hello, World!&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">byte</span>[] ciphertext = encipher.doFinal(plaintext);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化用于解密的 Cipher 实例，使用相同的密钥和 IV</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">decipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/CTR/PKCS5Padding&quot;</span>);</span><br><span class="line">        decipher.init(Cipher.DECRYPT_MODE, key, iv);</span><br><span class="line">        <span class="comment">//输出密文</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(ciphertext, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">// 解密密文</span></span><br><span class="line">        <span class="type">byte</span>[] decrypted = decipher.doFinal(ciphertext);</span><br><span class="line">        <span class="comment">//输出解密后的明文</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(decrypted, StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查解密后的明文是否和原明文相同</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Decryption successful? &quot;</span> + Arrays.equals(plaintext, decrypted));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ECB、CBC、CFB、OFB、CTR-的对比"><a href="#ECB、CBC、CFB、OFB、CTR-的对比" class="headerlink" title="ECB、CBC、CFB、OFB、CTR 的对比"></a>ECB、CBC、CFB、OFB、CTR 的对比</h2><table>
<thead>
<tr>
<th>模式</th>
<th>名称</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>ECB</td>
<td>Electronic CodeBook 电子密码本模式</td>
<td>简单、快速、加解密支持并行</td>
<td>1.明文重复密文也会重复<br />2.通过混淆密文就会导致明文混淆<br />3.解密错误的密文，对应分组也会错误<br />4.不能抵御重放攻击</td>
</tr>
<tr>
<td>CBC</td>
<td>Cipher Block Chaining 密文分组链接模式</td>
<td>明文重复不会反映在密文中<br />解密支持并行计算<br />可以解密任意密文分组</td>
<td>1.对包含错误信息的密文解密时第一个分组的全部比特以及后一个分组的相应比特都会出错<br />2.加密不支持并行计算</td>
</tr>
<tr>
<td>CFB</td>
<td>Cipher FeedBack 密文反馈模式</td>
<td>不需要填充，支持并行计算，能够解密任意分组密文</td>
<td>1.加密不支持并行计算<br />2.对包含错误信息的密文解密时第一个分组的全部比特以及后一个分组的相应比特都会出错<br />3.不能抵御重放攻击</td>
</tr>
<tr>
<td>OFB</td>
<td>OutputFeedBack 输出反馈模式</td>
<td>不需要填充<br />可事先进行加密、解密的准备<br />加解密使用相同结构<br />对包含某些错误比特的密文进行解密时，只有明文中对应的比特会出错</td>
<td>1.不支持并行计算<br />2.主动攻击者反转密文分钟的某些比特时，明文分组中对应的比特位也会被反转</td>
</tr>
<tr>
<td>CTR</td>
<td>CounTeR 计数器模式</td>
<td>不需要填充<br />可事先进行加密、解密的准备<br />加解密使用相同结构<br />对包含某些错误比特的密文进行解密时，只有明文中对应的比特会出错<br />支持并行计算（加解密）</td>
<td>1.主动攻击者反转密文分钟的某些比特时，明文分组中对应的比特位也会被反转</td>
</tr>
</tbody></table>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/密码技术-读书笔记/">密码技术,读书笔记</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/3573874495.html"><span>图解密码技术-对CFB模式的攻击</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/3573874495.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-14T14:40:07.000Z">
          2023-08-14
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="CFB模式简介"><a href="#CFB模式简介" class="headerlink" title="CFB模式简介"></a>CFB模式简介</h2><p>CFB模式全称是（Cipher FeedBack）<strong>密文反馈模式</strong>。加密方式是前一个密文分组会被送回到密码算法的输入端。简单理解就是，前一个密文分组在此加密后会当作下一次与明文异或运算的一部分，依次类推。如图：</p>
<img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/image-20230810223911494.png" alt="image-20230810223911494" style="zoom:100%;" />

<h2 id="CFB模式的解密"><a href="#CFB模式的解密" class="headerlink" title="CFB模式的解密"></a>CFB模式的解密</h2><p>因为CFB模式的加密利用了前一个密文分组，则解密的核心思路就是利用前一个明文分组的加密结果和当前密文进行异或运算得到当前明文。</p>
<h3 id="文字步骤如下："><a href="#文字步骤如下：" class="headerlink" title="文字步骤如下："></a>文字步骤如下：</h3><ol>
<li>解密端获得密文块C1、C2、C3…以及一个初始向量IV。</li>
<li>将IV进行加密,获得第一个密钥块K1。(使用的密钥和加密算法与加密端相同)</li>
<li>将密钥块K1与密文块C1进行异或,得到明文块P1。</li>
<li>将刚刚解密得到的明文块P1再次进行加密,生成下一个密钥块K2。</li>
<li>将K2与下一个密文块C2进行异或,得到明文块P2。</li>
<li>依此类推,重复步骤4和5,直到所有密文全部解密。</li>
</ol>
<h3 id="图示："><a href="#图示：" class="headerlink" title="图示："></a>图示：</h3><img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/image-20230814225641064.png" alt="image-20230814225641064" style="zoom:100%;" />

<h2 id="CFB模式的攻击"><a href="#CFB模式的攻击" class="headerlink" title="CFB模式的攻击"></a>CFB模式的攻击</h2><p>书中提到了一种攻击方式是<strong>重放攻击。</strong>（replay attack）</p>
<p>加入小美发送了一条信息，这条信息由4个密文组成。主动攻击者小明将消息的后3个密文分组保存下来，等第二天小美使用相同密钥再一次发送新消息的时候（新消息由4个新的密文组成）。小明就可以将昨天保存的密文分组进行替换。那么在解密的时候就会得到错误的信息。在真实的网络环境中，服务器与服务器之间的对话如果被攻击者利用进行重新发送或者延迟发送数据就会达到欺骗用户的目的。</p>
<h3 id="Java代码模拟重放攻击"><a href="#Java代码模拟重放攻击" class="headerlink" title="Java代码模拟重放攻击"></a>Java代码模拟重放攻击</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yt.mvcframework.v2.CFBDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.IvParameterSpec;</span><br><span class="line"><span class="keyword">import</span> java.security.Key;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.IvParameterSpec;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReplayAttackExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Cipher cipher;</span><br><span class="line">        <span class="keyword">private</span> SecretKey key;</span><br><span class="line">        <span class="keyword">private</span> Map&lt;Long, <span class="type">byte</span>[]&gt; seenMessages = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Server</span><span class="params">(SecretKey key, IvParameterSpec iv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.cipher = Cipher.getInstance(<span class="string">&quot;AES/CFB/NoPadding&quot;</span>);</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, key, iv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(<span class="type">long</span> timestamp, <span class="type">byte</span>[] ciphertext)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">if</span> (seenMessages.containsKey(timestamp) &amp;&amp;</span><br><span class="line">                    Arrays.equals(seenMessages.get(timestamp), ciphertext)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Replay attack detected!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] plaintext = cipher.doFinal(ciphertext);</span><br><span class="line">            System.out.println(<span class="string">&quot;Received message: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(plaintext));</span><br><span class="line"></span><br><span class="line">            seenMessages.put(timestamp, ciphertext);</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, key, <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(cipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Cipher cipher;</span><br><span class="line">        <span class="keyword">private</span> SecretKey key;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Client</span><span class="params">(SecretKey key, IvParameterSpec iv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.cipher = Cipher.getInstance(<span class="string">&quot;AES/CFB/NoPadding&quot;</span>);</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, key, iv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] sendMessage(String message) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">byte</span>[] ciphertext = cipher.doFinal(message.getBytes());</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, key, <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(cipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV()));</span><br><span class="line">            <span class="keyword">return</span> ciphertext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">KeyGenerator</span> <span class="variable">kg</span> <span class="operator">=</span> KeyGenerator.getInstance(<span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">key</span> <span class="operator">=</span> kg.generateKey();</span><br><span class="line"></span><br><span class="line">        <span class="type">SecureRandom</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line">        <span class="type">IvParameterSpec</span> <span class="variable">iv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(random.generateSeed(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Server</span>(key, iv);</span><br><span class="line">        <span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Client</span>(key, iv);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">byte</span>[] ciphertext = client.sendMessage(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        server.receiveMessage(timestamp, ciphertext);</span><br><span class="line">        server.receiveMessage(timestamp, ciphertext);  <span class="comment">// Attempt replay attack</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上述代码模拟中，客户端向服务器发送了一个加密的消息和一个时间戳，服务器接收到消息后解密并保存。然后，客户端再次发送相同的加密消息和时间戳，试图欺骗服务器认为这是一个新的、合法的消息。</p>
<p>服务器使用了一个简单的策略来防止重放攻击：它保存了所有接收到的消息和对应的时间戳。当接收到一个新的消息时，服务器会检查它是否已经接收过一个具有相同时间戳和加密消息的消息。如果是，那么服务器就认为这是一个重放攻击，并拒绝处理这个消息。</p>
<p>这个模拟的关键在于，服务器能够识别并拒绝重放的消息，即使这个消息是合法的并且正确加密的。这是因为在一个安全的系统中，每个消息都应该是唯一的，即使是两个完全相同的消息也应该有不同的时间戳或者序列号，以防止重放攻击。</p>
</blockquote>
<h3 id="碰撞攻击"><a href="#碰撞攻击" class="headerlink" title="碰撞攻击"></a>碰撞攻击</h3><p>CFB模式的加密存在一个缺点，那就是相同的明文会产生相同的密文。攻击者可以构造特殊的明文,使得产生大量相同的密文块,从而获取明文信息。</p>
<h3 id="Java代码模拟碰撞攻击"><a href="#Java代码模拟碰撞攻击" class="headerlink" title="Java代码模拟碰撞攻击"></a>Java代码模拟碰撞攻击</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.IvParameterSpec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CFBAttack</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成密钥</span></span><br><span class="line">    <span class="type">KeyGenerator</span> <span class="variable">kg</span> <span class="operator">=</span> KeyGenerator.getInstance(<span class="string">&quot;AES&quot;</span>);</span><br><span class="line">    <span class="type">SecretKey</span> <span class="variable">key</span> <span class="operator">=</span> kg.generateKey();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化IV</span></span><br><span class="line">    <span class="type">IvParameterSpec</span> <span class="variable">iv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置加密模式为CFB,并获得Cipher实例</span></span><br><span class="line">    <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/CFB/NoPadding&quot;</span>);</span><br><span class="line">    cipher.init(Cipher.ENCRYPT_MODE, key, iv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造明文block1和block2完全相同</span></span><br><span class="line">    <span class="type">byte</span>[] block1 = <span class="string">&quot;HelloWorld&quot;</span>.getBytes();</span><br><span class="line">    <span class="type">byte</span>[] block2 = <span class="string">&quot;HelloWorld&quot;</span>.getBytes();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加密两块明文</span></span><br><span class="line">    <span class="type">byte</span>[] cipherBlock1 = cipher.doFinal(block1);</span><br><span class="line">    <span class="type">byte</span>[] cipherBlock2 = cipher.doFinal(block2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个密文块由于明文相同也完全相同</span></span><br><span class="line">    <span class="comment">// 这可被攻击者利用来获取明文信息</span></span><br><span class="line">    <span class="keyword">if</span> (java.util.Arrays.equals(cipherBlock1, cipherBlock2)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Collision attack succeeded!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个简单的例子构造了相同的明文块,导致CFB模式下产生了相同的密文,模拟了碰撞攻击。实际上攻击者可以通过观察大量密文,找到碰撞的密文块,从而对明文信息进行推断。</p>
</blockquote>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/密码技术-读书笔记/">密码技术,读书笔记</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/427224952.html"><span>图解密码技术-OFB模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/427224952.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-11T15:02:01.000Z">
          2023-08-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="常见的分组密码以及特点"><a href="#常见的分组密码以及特点" class="headerlink" title="常见的分组密码以及特点"></a>常见的分组密码以及特点</h2><p>常见的分组密码有DES、AES、SM4、Blowfish等。</p>
<p>分组密码的特点</p>
<ol>
<li>分组长度固定，常见的块长度有64位、128位、256位等</li>
<li>可以将数据进行分组，切割为不同的数据块，每一块数据单独处理加密</li>
<li>使用对称密钥，加解密使用的是同一个密钥</li>
<li>加解密算法是确定的，相同的明文、密钥和加密算法会产生相同的密文</li>
</ol>
<h2 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h2><p>分组密码算法只能加密固定长度的分组，但是我们需要加密的明文可能会超过分组密码分组的长度，这时候就需要对明文进行切割，分成几组分别进行加密，直到所有的明文加密完成。这种方式就称之为分组密码的<strong>模式</strong>。</p>
<h3 id="分组密码的主要模式"><a href="#分组密码的主要模式" class="headerlink" title="分组密码的主要模式"></a>分组密码的主要模式</h3><ol>
<li>ECB模式：(Electronic CodeBook mode) 电子密码本模式</li>
<li>CBC模式：(Cipher Block Chaining mode) 密码分组链接模式</li>
<li>CFB模式：(Cipher FeedBack mode) 密文反馈模式</li>
<li>OFB模式：(Output FeedBack mode)输出反馈模式</li>
<li>CTR模式：(CounTeR mode) 计数器模式</li>
</ol>
<p>今天来了解一下OFB模式</p>
<h2 id="OFB模式（Output-Feedback-Mode）"><a href="#OFB模式（Output-Feedback-Mode）" class="headerlink" title="OFB模式（Output Feedback Mode）"></a>OFB模式（Output Feedback Mode）</h2><p>OFB模式我们称之为密文反馈模式。它的工作原理跟CFB模式非常相似，但是OCB模式是利用前一个密文块来作为下一次加密的密钥。如图所示</p>
<p><img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/image-20230815215333577.png" alt="image-20230815215333577"></p>
<p>在看一下CFB模式的图</p>
<img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/image-20230810223911494.png" alt="image-20230810223911494" style="zoom:67%;" />

<p>下面是书中对这两种模式区别的介绍</p>
<blockquote>
<p>OFB 模式和CFB模式的区别仅仅在于<strong>密码算法的输入</strong>。ps:我没懂….</p>
<p>CFB 模式中，密码算法的输入是前一个密文分组，也就是将密文分组反馈到密码算法中，因此得名“密文反馈模式”</p>
<p>相对的，OFB模式中，密码算法的输入则是密码算法的前一个输出。也就是将输出反馈给密码算法。因此得名“输出反馈模式”</p>
</blockquote>
<p>上面的两段话，我读了很多遍。有一个疑问是：OFB模式中，密码算法的输入则是密码算法的前一个输出。这句话怎么理解呢？</p>
<p>OFB模式的加密过程是:</p>
<ol>
<li>首先利用初始化向量IV进行一次加密运算,生成第一个密钥流块K1。</li>
<li>将密钥流块K1与第一个明文块P1进行异或,得到第一个密文块C1。</li>
<li>将刚刚生成的密文块C1再次进行加密,生成下一个密钥流块K2。</li>
<li>K2同第二个明文块P2进行异或,生成密文块C2。</li>
<li>依此类推,重复步骤3和4,直到全部明文加密完毕。</li>
</ol>
<h2 id="JAVA-代码实现OFB模式加密和解密"><a href="#JAVA-代码实现OFB模式加密和解密" class="headerlink" title="JAVA 代码实现OFB模式加密和解密"></a>JAVA 代码实现OFB模式加密和解密</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yt.mvcframework.v2.OFBDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.IvParameterSpec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OFBEncrypt</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    OFB模式加密示意图:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    +------------+  +------------+</span></span><br><span class="line"><span class="comment">    |            |  |            |</span></span><br><span class="line"><span class="comment">    |   明文P1   |  |   密钥流   |</span></span><br><span class="line"><span class="comment">    |            |  |     K1     |</span></span><br><span class="line"><span class="comment">    +----+-------+  +------+-----+</span></span><br><span class="line"><span class="comment">         |               |</span></span><br><span class="line"><span class="comment">         |               |</span></span><br><span class="line"><span class="comment">         |               |</span></span><br><span class="line"><span class="comment">    +----v-------+       |</span></span><br><span class="line"><span class="comment">    |            |       |</span></span><br><span class="line"><span class="comment">    |   密文C1   &lt;-------+</span></span><br><span class="line"><span class="comment">    |            |</span></span><br><span class="line"><span class="comment">    +------------+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 生成AES密钥</span></span><br><span class="line">        <span class="type">KeyGenerator</span> <span class="variable">kg</span> <span class="operator">=</span> KeyGenerator.getInstance(<span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">key</span> <span class="operator">=</span> kg.generateKey();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 初始化一个全零的IV</span></span><br><span class="line">        <span class="type">IvParameterSpec</span> <span class="variable">iv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 获取Cipher实例,指定OFB模式</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/OFB/NoPadding&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 初始化Cipher为加密模式,使用key和iv</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, key, iv);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 明文</span></span><br><span class="line">        <span class="type">byte</span>[] plaintext = <span class="string">&quot;Hello World&quot;</span>.getBytes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 加密明文,得到密文</span></span><br><span class="line">        <span class="type">byte</span>[] ciphertext = cipher.doFinal(plaintext);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;OFB Encryption: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(ciphertext));</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, key, iv);</span><br><span class="line">        <span class="type">byte</span>[] decrypted = cipher.doFinal(ciphertext);</span><br><span class="line">        System.out.println(<span class="string">&quot;OFB Decryption: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(decrypted));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/密码技术-读书笔记/">密码技术,读书笔记</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/4282522732.html"><span>图解密码技术-CFB模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/4282522732.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-10T14:15:39.000Z">
          2023-08-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<blockquote>
<p>分组密码(Block Cipher)是一种密码对称加密算法，特点是按照固定长度的块(block)来对数据进行加密和解密。</p>
</blockquote>
</blockquote>
<h2 id="常见的分组密码以及特点"><a href="#常见的分组密码以及特点" class="headerlink" title="常见的分组密码以及特点"></a>常见的分组密码以及特点</h2><p>常见的分组密码有DES、AES、SM4、Blowfish等。</p>
<p>分组密码的特点</p>
<ol>
<li>分组长度固定，常见的块长度有64位、128位、256位等</li>
<li>可以将数据进行分组，切割为不同的数据块，每一块数据单独处理加密</li>
<li>使用对称密钥，加解密使用的是同一个密钥</li>
<li>加解密算法是确定的，相同的明文、密钥和加密算法会产生相同的密文</li>
</ol>
<h2 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h2><p>分组密码算法只能加密固定长度的分组，但是我们需要加密的明文可能会超过分组密码分组的长度，这时候就需要对明文进行切割，分成几组分别进行加密，直到所有的明文加密完成。这种方式就称之为分组密码的<strong>模式</strong>。</p>
<h3 id="分组密码的主要模式"><a href="#分组密码的主要模式" class="headerlink" title="分组密码的主要模式"></a>分组密码的主要模式</h3><ol>
<li>ECB模式：(Electronic CodeBook mode) 电子密码本模式</li>
<li>CBC模式：(Cipher Block Chaining mode) 密码分组链接模式</li>
<li>CFB模式：(Cipher FeedBack mode) 密文反馈模式</li>
<li>OFB模式：(Output FeedBack mode)输出反馈模式</li>
<li>CTR模式：(CounTeR mode) 计数器模式</li>
</ol>
<p>今天来了解一下CFB模式。</p>
<h3 id="CFB模式"><a href="#CFB模式" class="headerlink" title="CFB模式"></a>CFB模式</h3><p>CFB模式的全称是 Cipher FeedBack mode（密文反馈模式）。在CFB中模式中，前一个密文分组会被送回到密码算法的输入端。简单理解就是，前一个密文分组在此加密后会当作下一次与明文异或运算的一部分，依次类推。加密过程如下图：</p>
<img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/image-20230810223911494.png" alt="image-20230810223911494" style="zoom:67%;" />

<p><strong>在CBC模式中</strong>，前一个密文分组要和明文组先进行异或运算然后加密最后产生密文分组。如同：</p>
<img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/image-20230810224528410.png" alt="image-20230810224528410" style="zoom:67%;" />

<p><strong>在CFB模式中</strong>，前一个密文分组先进行了加密然后使用加密后的数据和下一个明文分组进行异或运算最后产生密文分组。</p>
<img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/image-20230810224543646.png" alt="image-20230810224543646" style="zoom:67%;" />

<p>在CFB模式中，密码算法的输出值会当作下一次与明文加密的“初始化向量”。书中使用了更加专业的术语——“<strong>密钥流</strong>”。密码算法就相当于一个伪随机数的生成器，而真正的初始化向量则为一个源头。明文数据可以被一个比特一个比特的加密，因此我们可以将CFB模式看做是使用了分组密码来实现<strong>流密码</strong>的一种方式。</p>
<h3 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h3><blockquote>
<p>简单解释就是，加密的密钥流比喻为一个旋转门，我们需要加密的明文就像是一群人。这个旋转门每次只能过去一个人，当所有人一个个的通过旋转门的时候就会与当前旋转门进行一次异或运算。旋转门每一次转动都会产生一个不同的数字，这样当人通过的时候异或的结果也不一样。最终当所有人通过那么就会得到最后的加密之后的数据。</p>
</blockquote>
<h3 id="Java代码实现CFB加解密"><a href="#Java代码实现CFB加解密" class="headerlink" title="Java代码实现CFB加解密"></a>Java代码实现CFB加解密</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">           <span class="comment">// 创建一个AES密钥</span></span><br><span class="line">           <span class="type">SecretKeySpec</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(<span class="string">&quot;1234567890123456&quot;</span>.getBytes(StandardCharsets.UTF_8), <span class="string">&quot;AES&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 创建一个初始化向量</span></span><br><span class="line">           <span class="type">IvParameterSpec</span> <span class="variable">iv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(<span class="string">&quot;1234567890123456&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 创建一个AES/CFB/PKCS5Padding模式的Cipher</span></span><br><span class="line">           <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/CFB/PKCS5Padding&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 初始化Cipher为加密模式，设置密钥和初始化向量</span></span><br><span class="line">           cipher.init(Cipher.ENCRYPT_MODE, key, iv);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 对&quot;Hello World&quot;字符串进行加密</span></span><br><span class="line">           <span class="type">byte</span>[] encrypted = cipher.doFinal(<span class="string">&quot;Hello World&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 将加密后的数据进行Base64编码，方便打印</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">encryptedBase64</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(encrypted);</span><br><span class="line">           System.out.println(<span class="string">&quot;Encrypted: &quot;</span> + encryptedBase64);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 初始化Cipher为解密模式，设置密钥和初始化向量</span></span><br><span class="line">           cipher.init(Cipher.DECRYPT_MODE, key, iv);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 对加密后的数据进行解密</span></span><br><span class="line">           <span class="type">byte</span>[] decrypted = cipher.doFinal(Base64.getDecoder().decode(encryptedBase64));</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 打印解密后的字符串</span></span><br><span class="line">           System.out.println(<span class="string">&quot;Decrypted: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(decrypted, StandardCharsets.UTF_8));</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h3 id="CFB模式的攻击方式"><a href="#CFB模式的攻击方式" class="headerlink" title="CFB模式的攻击方式"></a>CFB模式的攻击方式</h3><blockquote>
<p>书中攻击方式我没有看懂….后期补上</p>
</blockquote>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/密码技术-读书笔记/">密码技术,读书笔记</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/3716094242.html"><span>图解密码技术-CBC模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/3716094242.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-09T14:27:33.000Z">
          2023-08-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>分组密码(Block Cipher)是一种密码对称加密算法，特点是按照固定长度的块(block)来对数据进行加密和解密。</p>
</blockquote>
<h2 id="常见的分组密码以及特点"><a href="#常见的分组密码以及特点" class="headerlink" title="常见的分组密码以及特点"></a>常见的分组密码以及特点</h2><p>常见的分组密码有DES、AES、SM4、Blowfish等。</p>
<p>分组密码的特点</p>
<ol>
<li>分组长度固定，常见的块长度有64位、128位、256位等</li>
<li>可以将数据进行分组，切割为不同的数据块，每一块数据单独处理加密</li>
<li>使用对称密钥，加解密使用的是同一个密钥</li>
<li>加解密算法是确定的，相同的明文、密钥和加密算法会产生相同的密文</li>
</ol>
<h2 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h2><p>分组密码算法只能加密固定长度的分组，但是我们需要加密的明文可能会超过分组密码分组的长度，这时候就需要对明文进行切割，分成几组分别进行加密，直到所有的明文加密完成。这种方式就称之为分组密码的<strong>模式</strong>。</p>
<h3 id="分组密码的主要模式"><a href="#分组密码的主要模式" class="headerlink" title="分组密码的主要模式"></a>分组密码的主要模式</h3><ol>
<li>ECB模式：(Electronic CodeBook mode) 电子密码本模式</li>
<li>CBC模式：(Cipher Block Chaining mode) 密码分组链接模式</li>
<li>CFB模式：(Cipher FeedBack mode) 密文反馈模式</li>
<li>OFB模式：(Output FeedBack mode)输出反馈模式</li>
<li>CTR模式：(CounTeR mode) 计数器模式</li>
</ol>
<h3 id="ECB模式"><a href="#ECB模式" class="headerlink" title="ECB模式"></a>ECB模式</h3><p>书中介绍ECB模式是将明文直接分组，然后进行分别加密处理。如图：</p>
<p><img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/image-20230809225412547.png" alt="image-20230809225412547"></p>
<p>从图中可以直观的看出来，明文的分组和密文的分组是完全一致的。在EDB模式中，明文分组和密文分组是一一对应关系，那么如果明文中有两组以上相同的内容那么这些密文也会一样。所以，ECB模式是不安全的。</p>
<h3 id="Java代码实现ECB加密"><a href="#Java代码实现ECB加密" class="headerlink" title="Java代码实现ECB加密"></a>Java代码实现ECB加密</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">// 创建一个AES密钥</span></span><br><span class="line">       <span class="type">SecretKeySpec</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(<span class="string">&quot;1234567890123456&quot;</span>.getBytes(StandardCharsets.UTF_8), <span class="string">&quot;AES&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 创建一个AES/ECB/PKCS5Padding模式的Cipher</span></span><br><span class="line">       <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/ECB/PKCS5Padding&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 初始化Cipher为加密模式，设置密钥</span></span><br><span class="line">       cipher.init(Cipher.ENCRYPT_MODE, key);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 对&quot;Hello World&quot;字符串进行加密</span></span><br><span class="line">       <span class="type">byte</span>[] encrypted = cipher.doFinal(<span class="string">&quot;Hello World&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将加密后的数据进行Base64编码，方便打印</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">encryptedBase64</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(encrypted);</span><br><span class="line">       System.out.println(<span class="string">&quot;Encrypted: &quot;</span> + encryptedBase64);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 初始化Cipher为解密模式，设置密钥</span></span><br><span class="line">       cipher.init(Cipher.DECRYPT_MODE, key);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 对加密后的数据进行解密</span></span><br><span class="line">       <span class="type">byte</span>[] decrypted = cipher.doFinal(Base64.getDecoder().decode(encryptedBase64));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 打印解密后的字符串</span></span><br><span class="line">       System.out.println(<span class="string">&quot;Decrypted: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(decrypted, StandardCharsets.UTF_8));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="对ECB模式的攻击"><a href="#对ECB模式的攻击" class="headerlink" title="对ECB模式的攻击"></a>对ECB模式的攻击</h3><p><strong>举一个例子：</strong></p>
<p>假设我们有一个转账的业务，转账的数据由三部分组成；</p>
<p>分组A = 付款人小明</p>
<p>分组B=收款人小红</p>
<p>分组C=金额</p>
<p>那么使用ECB模式加密和被攻击的动作如下：</p>
<p><img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/image-20230809230257293.png" alt="image-20230809230257293"></p>
<p>如上图，黑客只是简单的调换了密文的顺序，并没有破译密文，就已经达到攻击的目的。</p>
<blockquote>
<p>原本由小明付款，现在变成了小红付款</p>
</blockquote>
<p>在ECB模式中，只要将任意密文调换位置，相应的明文也会变换位置，替换密文，明文也会被替换，删除密文，明文也会被删除。所以ECB模式是不安全的。</p>
<h3 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h3><p>CBC模式是将前一个密文分组与当前明文分组的内容混合起来进行加密，如图</p>
<p><img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/image-20230809231050229.png" alt="image-20230809231050229"></p>
<p>在CBC模式中，首先将明文分组与前一个密文分组进行异或运算，然后再进行加密。那么，这里会有一个问题，就是第一个明文分组应该与谁进行异或运算呢？</p>
<h3 id="初始化向量"><a href="#初始化向量" class="headerlink" title="初始化向量"></a>初始化向量</h3><p>当第一个明文加密这时候并不存在“前一个密文分组”。所以，我们需要准备一个初始化值，这个值的长度与分组比特位一致。我们成这个初始化值为<strong>初始化向量</strong>(Initialization Vector)，通常简写为IV。</p>
<h3 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h3><p>异或是一种逻辑运算,对应的逻辑符号是 ⊕；如下表格表示了运算结果</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">A ⊕ B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<h4 id="异或运算有以下几个特点"><a href="#异或运算有以下几个特点" class="headerlink" title="异或运算有以下几个特点:"></a>异或运算有以下几个特点:</h4><ol>
<li>当两个输入相同时,输出为0。当两个输入不同时,输出为1。</li>
<li>异或运算满足交换律和结合律。</li>
<li>一个数异或它本身结果为0。</li>
<li>一个数异或0等于本身。</li>
</ol>
<h4 id="CBC模式的特点"><a href="#CBC模式的特点" class="headerlink" title="CBC模式的特点"></a>CBC模式的特点</h4><p>因为明文分组在加密之前会和初始化向量进行异或运算，那么即使明文分组1和明文分组2的值是一样的，那么加密结果也会不同。例如：</p>
<p>明文分组1 = 001</p>
<p>明文分组2 = 001</p>
<p>初始化向量 = 000</p>
<p>明文分组1与初始化向量运算结果 001 ⊕ 000 = 001 </p>
<p>明文分组1与明文分组2运算结果 001 ⊕ 001 = 000</p>
<p>因为分组1需要跟初始化向量进行异或，得到的结果必然是不同的。</p>
<h4 id="Java实现CBC加密"><a href="#Java实现CBC加密" class="headerlink" title="Java实现CBC加密"></a>Java实现CBC加密</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 初始化向量，用于CBC模式的加密</span></span><br><span class="line">        <span class="type">byte</span>[] iv = <span class="keyword">new</span> <span class="title class_">byte</span>[] &#123;<span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x04</span>, <span class="number">0x05</span>, <span class="number">0x06</span>, <span class="number">0x07</span>, <span class="number">0x08</span>, <span class="number">0x09</span>, <span class="number">0x0a</span>, <span class="number">0x0b</span>, <span class="number">0x0c</span>, <span class="number">0x0d</span>, <span class="number">0x0e</span>, <span class="number">0x0f</span>&#125;;</span><br><span class="line">        <span class="type">IvParameterSpec</span> <span class="variable">ivspec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(iv);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个AES密钥</span></span><br><span class="line">        <span class="type">SecretKeySpec</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[] &#123;<span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x04</span>, <span class="number">0x05</span>, <span class="number">0x06</span>, <span class="number">0x07</span>, <span class="number">0x08</span>, <span class="number">0x09</span>, <span class="number">0x0a</span>, <span class="number">0x0b</span>, <span class="number">0x0c</span>, <span class="number">0x0d</span>, <span class="number">0x0e</span>, <span class="number">0x0f</span>&#125;, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个AES/CBC/PKCS5Padding模式的Cipher</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS5Padding&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化Cipher为加密模式，设置密钥和初始化向量</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, key, ivspec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对&quot;Hello World&quot;字符串进行加密</span></span><br><span class="line">        <span class="type">byte</span>[] encrypted = cipher.doFinal(<span class="string">&quot;Hello World&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化Cipher为解密模式，设置密钥和初始化向量</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, key, ivspec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对加密后的数据进行解密</span></span><br><span class="line">        <span class="type">byte</span>[] decrypted = cipher.doFinal(encrypted);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印解密后的字符串</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(decrypted));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="对CBC模式的攻击"><a href="#对CBC模式的攻击" class="headerlink" title="对CBC模式的攻击"></a>对CBC模式的攻击</h3><h4 id="攻击初始化向量"><a href="#攻击初始化向量" class="headerlink" title="攻击初始化向量"></a>攻击初始化向量</h4><p>在加密时CBC模式需要一个初始化向量。这个数据必须是一个安全的、不可预测的随机数列。如果生成的初始化向量随机度不高，那么两个明文使用了相同的IV加密,两个密文的第一个块将是相同的。这样就会计算出第一个密文块,并且解密所有后续的块。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/密码技术-读书笔记/">密码技术,读书笔记</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/0.html"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/0.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-06-26T15:06:22.658Z">
          2023-06-26
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/image-20230626230547764.png" alt="image-20230626230547764"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/3017106146.html"><span>代理模式-静态代理</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/3017106146.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-05-29T15:04:35.000Z">
          2023-05-29
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="代理模式简述"><a href="#代理模式简述" class="headerlink" title="代理模式简述"></a>代理模式简述</h2><p><strong>代理模式</strong>（Proxy Pattern）是程序设计中的一种设计模式。</p>
<p>所谓的代理可以简单理解为是一个<strong>中介</strong>。举一个生活中常见的例子：假如小王需要请刘德华唱歌，但是小王自己联系不到刘德华本人，小王只能联系他的经纪人，那么这个经纪人就是刘德华的代理。</p>
<blockquote>
<p>在编程世界中，这个[代理者]就是一个<strong>类</strong>。这个类可以作为其它行为的接口。</p>
</blockquote>
<p>代理模式的[统一建模语言(UML)</p>
<p><img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/2880px-Proxy_pattern_diagram.svg.png" alt="[统一建模语言(UML)](https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/2880px-Proxy_pattern_diagram.svg-20230529230514395.png)图"></p>
<h2 id="代理的分类"><a href="#代理的分类" class="headerlink" title="代理的分类"></a>代理的分类</h2><h3 id="什么是静态代理"><a href="#什么是静态代理" class="headerlink" title="什么是静态代理"></a>什么是静态代理</h3><p>静态代理是代理模式的一种实现方式，它具有以下几个特点：</p>
<ol>
<li>目标对象和代理对象实现的是同一个业务接口。UML 图中的 Proxy 类就是代理对象， RealSubject 类就是目标对象</li>
<li>目标对象必须实现接口。UML 图中的 Proxy 实现了接口 Subject</li>
<li>代理对象在程序的运行之前已经存在</li>
<li>能够做到对目标对象的灵活切换，但是无法完成功能的灵活切换</li>
</ol>
<h4 id="业务实现"><a href="#业务实现" class="headerlink" title="业务实现"></a>业务实现</h4><p>唱歌。小王需要请刘德华唱歌，刘德华就是目标对象。</p>
<p>经纪人。经纪人就是代理对象。这个经纪人既可以跟小王对接，也可以跟车的刘德华对接。</p>
<p>小王，就是所谓的客户端。UML 中的 Client。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ol>
<li>定义买车的业务接口 Service</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">buyCar</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>目标对象 LiuDeHua</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">buyCar</span><span class="params">()</span>&#123;</span><br><span class="line">  Sout(<span class="string">&quot;我正在唱歌&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>定义代理对象Agent并实现与目标对象一样的接口；并实现买车动作前后需要完成的动作</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">buyCar</span><span class="params">()</span>&#123;</span><br><span class="line">  Sout(<span class="string">&quot;谈价钱&quot;</span>);</span><br><span class="line">  <span class="comment">//买车的动作，需要目标对象自己完成</span></span><br><span class="line">  <span class="type">LiuDeHua</span> <span class="variable">liudehua</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiuDeHua</span>();</span><br><span class="line">  liudehua.buyCat();</span><br><span class="line">  Sout(<span class="string">&quot;唱完歌，结账&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>测试</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">//new 出来代理类</span></span><br><span class="line">  <span class="type">Agent</span> <span class="variable">agent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Agent</span>();</span><br><span class="line">  agent.sing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>琢磨下：上述例子中，我们只能代理刘德华，那如果来了陈奕迅我们应该怎么办呢？</p>
<h2 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h2><p><strong>类中的成员变量设计为接口，方法的形参设计为接口，方法的返回值设计为接口，调用时接口指向实现类</strong></p>
<p>首先，在上面的例子中，我们的代理类 Agent在自己的类中new了一个 LiuDeHua的实例，然后完成了唱歌前的定价动作和唱歌后的结账动作。那么，这时候我们只能听到刘德华唱的歌。那如果我们现在想要听陈奕迅的歌，应该怎么办呢？难道在 Agent 中在 new 一个 ChenYiXun 的实例吗？我们的代理类（经纪人）每次只能代理一个实例（明星）啊。这时候，我们就要采用<strong>面向接口编程</strong>的方式了。</p>
<ol>
<li>我们已经知道有一个接口 Service中有 sing()方法。那么接下来我们将Service 作为Agent 类的成员变量</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agent</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类中的成员变量设计为接口</span></span><br><span class="line">    <span class="keyword">public</span> Service target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>我们实现一个带有参数的构造方法：将 Service 作为参数传进去</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agent</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类中的成员变量设计为接口</span></span><br><span class="line">    <span class="keyword">public</span> Service target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入目标对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Agent</span><span class="params">(Service target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>最后，我们将调用的方法，由直接 new 实现类改为接口指向</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agent</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类中的成员变量设计为接口</span></span><br><span class="line">    <span class="keyword">public</span> Service target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入目标对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Agent</span><span class="params">(Service target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;谈价钱....&quot;</span>);</span><br><span class="line">        <span class="comment">//业务功能必须使用目标对象</span></span><br><span class="line">        <span class="comment">//面向接口编程，调用时，接口指向实现类；target就是传进来的实现类，刘德华或者陈奕迅等等....</span></span><br><span class="line">        target.sing();</span><br><span class="line">        System.out.println(<span class="string">&quot;唱完结账.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyTest 类中的代码：</p>
<ol>
<li>第一版；此时 new Agent()调用的是无参构造</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Agent</span> <span class="variable">agent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Agent</span>();</span><br><span class="line">  agent.sing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>第二版；new Agent(Service target)调用的是参数为 Service 接口的有参构造；此时，会调用 Agent 的有参构造方法</li>
</ol>
<p><code>public Agent(Service target) &#123;this.target = target;&#125;</code></p>
<p>此时做到了接口指向实现类的动作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Agent</span> <span class="variable">agent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Agent</span>(<span class="keyword">new</span> <span class="title class_">ChenYiXun</span>());</span><br><span class="line">  agent.sing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们实现了一个简单的静态代理，简单了解了面向接口编程的思想。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/设计模式，静态代理，Java/">设计模式，静态代理，Java</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/402495650.html"><span>爱，至关重要</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/402495650.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-05-28T12:26:38.000Z">
          2023-05-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="自律"><a href="#自律" class="headerlink" title="自律"></a>自律</h2>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/爱，自律，为人父母/">爱，自律，为人父母</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2023 Liberte
    
  </p>
本站总访问量<span id="busuanzi_value_site_pv"></span>次
</footer>
    
    
  </div>
</div>
</body>
</html>