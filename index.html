<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Liberte blog</title>

  
  <meta name="author" content="Liberte">
  

  

  
  <meta name="keywords" content="Java,Spring,Notes">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Liberte blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Liberte blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Liberte blog</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/search">搜索</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/blog/1599102989.html"><span>Java 面试十大烂问题</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/1599102989.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-09-23T08:44:38.000Z">
          2023-09-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <ol>
<li><h3 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h3><p>面向对象编程（OOP）主要是基于四个原则：封装、集成、多态、抽象。</p>
<p>这四个原则共同构成了面向对象编程的基础。在代码的提现上则会使得代码模块化、可重用以及更加容易维护。</p>
<p>封装使得代码内部的细节实现得以屏蔽，隐藏了代码内部的复杂性，继承则可以使得代码重复使用以及职责单一化，多态则允许对象之间互相转换，抽象侧重于将复杂的业务模型化、简单化</p>
</li>
<li><h4 id="Java-中最快的搜索算法"><a href="#Java-中最快的搜索算法" class="headerlink" title="Java 中最快的搜索算法"></a>Java 中最快的搜索算法</h4><p>Java 中比较常见且最常使用的算法是二分搜索和 hash 搜索。二分搜索主要适用于已经有序的数组或者列表。时间复杂度是O(log n)。</p>
<h5 id="Java代码实现二分查找"><a href="#Java代码实现二分查找" class="headerlink" title="Java代码实现二分查找"></a>Java代码实现二分查找</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.toca.bjca;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearchExample</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> array.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (array[mid] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &lt; target) &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// Target element not found</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">38</span>, <span class="number">56</span>, <span class="number">72</span>, <span class="number">91</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> binarySearch(array, target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Element found at index: &quot;</span> + index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Element not found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>hash 搜索则是基于 hash 值的定位进行查找数据。主要是使用 HashMap 或者 HashSet这种数据结构，时间复杂度是 O((1))。</p>
<h5 id="java-代码实现-Hash-搜索"><a href="#java-代码实现-Hash-搜索" class="headerlink" title="java 代码实现 Hash 搜索"></a>java 代码实现 Hash 搜索</h5></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  map.put(<span class="string">&quot;John&quot;</span>, <span class="number">25</span>);</span><br><span class="line">  map.put(<span class="string">&quot;Jane&quot;</span>, <span class="number">30</span>);</span><br><span class="line">  map.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">42</span>);</span><br><span class="line">  map.put(<span class="string">&quot;Bob&quot;</span>, <span class="number">35</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;Jane&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    System.out.println(<span class="string">&quot;Value for key &quot;</span> + key + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Key not found&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-JDK-和-JRE-是什么"><a href="#3-JDK-和-JRE-是什么" class="headerlink" title="3 JDK 和 JRE 是什么"></a>3 JDK 和 JRE 是什么</h4><p>JDK 代表的是 Java 开发工具包，JRE 是 Java 的运行时环境。JDK 是一个软件包，包括 Java 开发所需的一些工具例如：编译器、调试器、Java API，JDK 中还包括 JRE。</p>
<p>JRE 则是Java运行时环境。但是不包含开发工具</p>
<h4 id="4-谈谈多线程"><a href="#4-谈谈多线程" class="headerlink" title="4 谈谈多线程"></a>4 谈谈多线程</h4><p>多线程是指在单个应用程序中同时间可以运行一个以上的线程任务。线程是轻量级的执行单元，它允许任务同时执行，从而提高应用程序的执行性能和响应能力。多线程执行任务还可以更大限度的利用多核 CPU 实现并行的任务处理，例如 I/O 操等</p>
<h5 id="Java-中的多线程"><a href="#Java-中的多线程" class="headerlink" title="Java 中的多线程"></a>Java 中的多线程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">// Create two threads</span></span><br><span class="line">  <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;Thread 1&quot;</span>));</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;Thread 2&quot;</span>));</span><br><span class="line">  <span class="comment">// Start the threads</span></span><br><span class="line">  thread1.start();</span><br><span class="line">  thread2.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String threadName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyRunnable</span><span class="params">(String threadName)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.threadName = threadName;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">//process bus</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">      System.out.println(threadName + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// Pause for 1 second</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-java中创建对象的方法"><a href="#5-java中创建对象的方法" class="headerlink" title="5 java中创建对象的方法"></a>5 java中创建对象的方法</h4><p>在 Java 中创建对象的方法有四种：使用 new 关键字、调用 clone()、使用反射创建对象、使用反序列化创建对象。</p>
<h5 id="Java-代码示例"><a href="#Java-代码示例" class="headerlink" title="Java 代码示例"></a>Java 代码示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using the new keyword</span></span><br><span class="line"><span class="type">MyObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cloning an object</span></span><br><span class="line"><span class="type">MyObject</span> <span class="variable">obj2</span> <span class="operator">=</span> obj.clone();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creating an object using reflection</span></span><br><span class="line">Class&lt;MyObject&gt; clazz = MyObject.class;</span><br><span class="line"><span class="type">MyObject</span> <span class="variable">obj3</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creating an object through deserialization</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line"><span class="type">MyObject</span> <span class="variable">obj4</span> <span class="operator">=</span> (MyObject) in.readObject();</span><br></pre></td></tr></table></figure>

<h4 id="6比较-Java-中的接口和抽象类。为什么更喜欢接口而不是抽象类？"><a href="#6比较-Java-中的接口和抽象类。为什么更喜欢接口而不是抽象类？" class="headerlink" title="6比较 Java 中的接口和抽象类。为什么更喜欢接口而不是抽象类？"></a>6比较 Java 中的接口和抽象类。为什么更喜欢接口而不是抽象类？</h4><p>接口和抽象类都允许定义类的共同行为。然而，接口提供了纯粹的抽象，允许类实现多个接口，而一个类只能扩展一个抽象类。接口定义契约，从而实现组件之间的松散耦合。抽象类提供部分实现，并且可以具有实例变量、构造函数和非抽象方法。当类需要支持多种行为或创建公共 API 时，接口是首选。</p>
<h4 id="7-解释一下Java中Comparator和Comparable接口的区别"><a href="#7-解释一下Java中Comparator和Comparable接口的区别" class="headerlink" title="7 解释一下Java中Comparator和Comparable接口的区别"></a>7 解释一下Java中Comparator和Comparable接口的区别</h4><p>Java中Comparator和Comparable都是用于对象比较的。 Comparable 接口由类实现，以定义其对象的自然顺序。它提供了一个 <code>compareTo()</code> 方法来比较对象。 Comparator 接口允许对可能没有自然排序的对象进行自定义比较逻辑。它提供了一个 <code>compare()</code> 方法来执行比较。虽然 Comparable 强加了自然排序，但 Comparator 允许灵活地定义不同的比较策略。</p>
<h5 id="Java-代码示例-1"><a href="#Java-代码示例-1" class="headerlink" title="Java 代码示例"></a>Java 代码示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name.compareTo(other.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Comparator interface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgeComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Person&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person p1, Person p2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p1.getAge() - p2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8HashMap-与-HashTable"><a href="#8HashMap-与-HashTable" class="headerlink" title="8HashMap 与 HashTable"></a>8HashMap 与 HashTable</h4><p>HashMap和HashTable都是用来存储键值对的。然而，HashTable 是一个同步类，使其线程安全，但可能速度较慢。 HashMap 不是同步的，提供了更好的性能，但本质上不是线程安全的。 HashMap 允许空键和值，而 HashTable 不允许空值。在大多数情况下，除非明确要求线程安全，否则 HashMap 是首选</p>
<h4 id="9-Java-中-LinkedList-和-List-接口的区别"><a href="#9-Java-中-LinkedList-和-List-接口的区别" class="headerlink" title="9 Java 中 LinkedList 和 List 接口的区别"></a>9 Java 中 LinkedList 和 List 接口的区别</h4><p>List 接口是 Java Collections Framework 中的一个基本接口，表示有序集合。 LinkedList 是 List 接口的实现，它将元素存储在双向链表中。 LinkedList提供了高效的两端元素插入和删除，但随机访问速度较慢。 ArrayList 是另一种 List 实现，它将元素存储在动态调整大小的数组中，与 LinkedList 相比，提供更快的随机访问，但插入和删除速度更慢</p>
<h4 id="10-解释一下Java中引用值和变量值的区别。"><a href="#10-解释一下Java中引用值和变量值的区别。" class="headerlink" title="10 解释一下Java中引用值和变量值的区别。"></a>10 解释一下Java中引用值和变量值的区别。</h4><p>在 Java 引用值是指向对象内存地址的。它允许访问和操作对象的属性和方法。变量值则是变量所保存的实际值。对于原始数据类型（例如 int  boolean）变量值是直接分配给变量的值。对于引用类型（例如 new  User()）变量值就是引用值指向内存地址。</p>
<h5 id="Java-代码"><a href="#Java-代码" class="headerlink" title="Java 代码"></a>Java 代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.toca.bjca;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceValueVsVariableValueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">variableValue</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">anotherVariableValue</span> <span class="operator">=</span> variableValue;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Variable Value: &quot;</span> + variableValue);</span><br><span class="line">        System.out.println(<span class="string">&quot;Another Variable Value: &quot;</span> + anotherVariableValue);</span><br><span class="line"></span><br><span class="line">        anotherVariableValue = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Variable Value: &quot;</span> + variableValue);</span><br><span class="line">        System.out.println(<span class="string">&quot;Another Variable Value: &quot;</span> + anotherVariableValue);</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> person1;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Person 1: &quot;</span> + person1.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Person 2: &quot;</span> + person2.getName());</span><br><span class="line"></span><br><span class="line">        person2.setName(<span class="string">&quot;Jane&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Person 1: &quot;</span> + person1.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Person 2: &quot;</span> + person2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码表明：变量的值是相互独立的，引用值指向内存地址中的一个对象。修改引用值则会影响到此对象的所有引用，因为内存地址发生了变化。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/面试-Non-template-issues/">面试 Non-template issues</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/3171891702.html"><span>性能之巅-读书笔记（1）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/3171891702.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-09-21T14:33:06.000Z">
          2023-09-21
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h4 id="system-wide-analysis-意思是对整个系统进行的分析。"><a href="#system-wide-analysis-意思是对整个系统进行的分析。" class="headerlink" title="system-wide analysis 意思是对整个系统进行的分析。"></a>system-wide analysis 意思是对整个系统进行的分析。</h4><p>这个词语通常用在复杂的系统或组织上,表示要采取全面而综合的方式来分析这个系统。</p>
<p>例如:</p>
<ol>
<li><p>对公司的system-wide analysis,以找出生产过程中的问题所在。</p>
</li>
<li><p>对城市交通系统进行system-wide analysis,以确定哪些地方出现拥堵。</p>
</li>
<li><p>对教育体系进行system-wide analysis,找出影响教学质量的因素。</p>
</li>
<li><p>对病人的健康问题进行system-wide analysis,不仅看身体症状,也要分析生活方式、工作环境等因素。</p>
</li>
<li><p>政府进行关于贫困问题的system-wide analysis,分析经济、社会、教育等各方面因素。</p>
</li>
</ol>
<p>简单来说,system-wide analysis就是采取全面和综合的视角,从不同层面、不同方面来分析一个大系统,找出系统性的问题所在,并给出建议或解决方案。它强调问题的复杂性和系统性,而不仅仅局限在某个狭窄的视野或层面。</p>
<p>capacity planning 翻译为容量规划或能力规划,是指对一个系统或组织的生产能力进行预估和规划,以满足当前和未来的业务需求。</p>
<h4 id="capacity-planning-的主要目的是确保有充足的资源和能力来应对业务增长或客户需求的变化-避免因容量不足而影响业务运营。进行-capacity-planning-通常会考虑以下几个方面"><a href="#capacity-planning-的主要目的是确保有充足的资源和能力来应对业务增长或客户需求的变化-避免因容量不足而影响业务运营。进行-capacity-planning-通常会考虑以下几个方面" class="headerlink" title="capacity planning 的主要目的是确保有充足的资源和能力来应对业务增长或客户需求的变化,避免因容量不足而影响业务运营。进行 capacity planning 通常会考虑以下几个方面:"></a>capacity planning 的主要目的是确保有充足的资源和能力来应对业务增长或客户需求的变化,避免因容量不足而影响业务运营。进行 capacity planning 通常会考虑以下几个方面:</h4><ol>
<li><p>分析历史需求模式,预测未来需求变化趋势。</p>
</li>
<li><p>评估现有设施、设备、人力等生产要素的能力和限制。</p>
</li>
<li><p>根据需求预测,计算所需要的新增产能。</p>
</li>
<li><p>制定容量扩充计划,如增加设备、场地、人员等。</p>
</li>
<li><p>确定所需资金投入,评估投资回报。</p>
</li>
<li><p>定期监控和审查已有容量,进行调整。</p>
</li>
<li><p>平衡好过剩和不足的风险。</p>
</li>
</ol>
<p>Capacity planning 适用于各种系统,如生产系统、仓储系统、IT系统、服务系统等。实施容量规划可以提高资源利用率,控制成本,为业务扩张做好准备。它通常是企业战略规划的重要组成部分。</p>
<p>性能领域包括以下事情</p>
<ol>
<li>设置性能目标和建立性能模型</li>
<li>基于软件或硬件原型进行性能特征归纳</li>
<li>对开发代码进行性能分析（软件整合之前）</li>
<li>执行软件非回归性测试（软件发布前或发布后）</li>
<li>针对软件发布版本的基准测试</li>
<li>目标环境中的概念验证（Proof-of-concept）测试</li>
<li>生产环境部署的配置优化</li>
<li>监控生产环境中运行的软件</li>
<li>特定问题的性能分析</li>
</ol>
<h4 id="Proof-of-concept-翻译为“概念证明”-意思是对一个想法、设计或方法的可行性进行验证和证明。"><a href="#Proof-of-concept-翻译为“概念证明”-意思是对一个想法、设计或方法的可行性进行验证和证明。" class="headerlink" title="Proof-of-concept 翻译为“概念证明”,意思是对一个想法、设计或方法的可行性进行验证和证明。"></a>Proof-of-concept 翻译为“概念证明”,意思是对一个想法、设计或方法的可行性进行验证和证明。</h4><p>通常包含以下主要特征:</p>
<ol>
<li><p>用最小可行的产品或方法来验证某一概念或理论是否可行。</p>
</li>
<li><p>目标是展示该概念在解决特定问题或需求方面的潜力和可行性。</p>
</li>
<li><p>可以是原型,也可以是模拟实验、模型等。重点在于获取验证该概念的有效性所需的预期数据。</p>
</li>
<li><p>如果结果满足预期,则提供继续投入研发的依据。如果不符合,则需要调整甚至放弃该概念。</p>
</li>
<li><p>整个过程充满试验性质,目标不是最终成品。</p>
</li>
</ol>
<p>举例来说,一个新产品在上市前会先做Proof-of-concept,来证明该产品的核心技术和设计在功能和用户体验上是可行的。一个医疗项目也会在临床试验前进行Proof-of-concept,以验证该疗法的科学理论基础。</p>
<p>所以,Proof-of-concept对于验证新想法的可行性非常重要,可以在投入大量资源开发前检验风险。它是任何概念从理论到实践的重要一步。</p>
<h4 id="负载分析-Load-Analysis-和资源分析-Resource-Analysis-都是对系统的性能和容量进行分析评估的方法。"><a href="#负载分析-Load-Analysis-和资源分析-Resource-Analysis-都是对系统的性能和容量进行分析评估的方法。" class="headerlink" title="负载分析(Load Analysis)和资源分析(Resource Analysis)都是对系统的性能和容量进行分析评估的方法。"></a>负载分析(Load Analysis)和资源分析(Resource Analysis)都是对系统的性能和容量进行分析评估的方法。</h4><p>负载分析主要是分析系统在正常或峰值负载下的运行状况,关键在于负载(Load)。</p>
<ul>
<li><p>它侧重对系统所承受的负载进行计量,如网络流量、并发用户请求、每秒交易量等。</p>
</li>
<li><p>通过设定不同负载参数,模拟系统在不同负载下的性能表现。</p>
</li>
<li><p>目的是确定系统的负载容量,防止超载,提供合理配置。</p>
</li>
</ul>
<p>资源分析主要是分析系统所需要的各种资源状况,关键在于资源(Resource)。</p>
<ul>
<li><p>它侧重对系统所需的关键资源进行分析,如服务器、带宽、内存、存储等。</p>
</li>
<li><p>对各种资源的供给与消耗情况进行测量和评估。</p>
</li>
<li><p>目的是合理配置和调配资源,提供系统所需的资源支持。</p>
</li>
</ul>
<p>简单来说,负载分析关注输入量,资源分析关注处理能力。它们通常要结合进行,才能全面评估系统的性能和容量,做出优化的配置和扩容方案。二者都是对系统的容量进行考量,但侧重点不同。</p>
<h2 id="纳秒（ns）：10-9秒-编辑"><a href="#纳秒（ns）：10-9秒-编辑" class="headerlink" title="纳秒（ns）：10-9秒[编辑]"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A5%88%E7%A7%92">纳秒</a>（ns）：10-9秒[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%95%B0%E9%87%8F%E7%BA%A7_(%E6%97%B6%E9%97%B4)&action=edit&section=7">编辑</a>]</h2><p>1纳秒(nanoseconds)即1000皮秒；也叫纳秒、奈秒、诺秒、纤秒、那诺秒、毫微秒。</p>
<ul>
<li>1纳秒– 1GHz的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CPU">CPU</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F">时钟周期</a>，该<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%91%A8%E6%9C%9F">周期</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%97%A0%E7%BA%BF%E7%94%B5%E6%B3%A2">无线电波</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%B3%A2%E9%95%BF">波长</a>0.3<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B1%B3_(%E5%8D%95%E4%BD%8D)">米</a>。</li>
<li>3.3纳秒 – 光传播一米所使用的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4">时间</a>。</li>
<li>10.9纳秒 – 铯 133 原子基态的超精细能级跃迁周期的大致长度。这个周期被用来定义秒的长度。</li>
<li>10纳秒 – 该<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%91%A8%E6%9C%9F">周期</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%97%A0%E7%BA%BF%E7%94%B5%E6%B3%A2">无线电波</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%B3%A2%E9%95%BF">波长</a>3<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B1%B3_(%E5%8D%95%E4%BD%8D)">米</a>。（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/VHF">VHF</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A2%91%E7%8E%87%E8%B0%83%E5%88%B6">FM</a>波段）</li>
<li>12纳秒 – K<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%8B%E5%AD%90">介子</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%8A%E8%A1%B0%E6%9C%9F">半衰期</a>。</li>
<li>100纳秒 – <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9F%AD%E6%B3%A2">短波</a>周期。</li>
<li>300纳秒 – <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%92%AB">钫-233</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%8A%E8%A1%B0%E6%9C%9F">半衰期</a></li>
</ul>
<h2 id="微秒（µs）：10-6秒-编辑"><a href="#微秒（µs）：10-6秒-编辑" class="headerlink" title="微秒（µs）：10-6秒[编辑]"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E7%A7%92">微秒</a>（µs）：10-6秒[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%95%B0%E9%87%8F%E7%BA%A7_(%E6%97%B6%E9%97%B4)&action=edit&section=8">编辑</a>]</h2><p>1微秒（microsecond）即1000纳秒。</p>
<ul>
<li>1微秒 – 商业高速<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A2%91%E9%97%AA%E8%A7%82%E6%B5%8B%E5%99%A8">频闪观测器</a>的闪动时间。</li>
<li>22.7微秒 – <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CD">CD</a>音乐的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%87%87%E6%A0%B7">采样</a>间隔（44.1<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/KHz">KHz</a>）</li>
<li>50微秒 – 人能够听到的最高<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A2%91%E7%8E%87">频率</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A3%B0%E9%9F%B3">声音</a>的周期（20<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/KHz">KHz</a>）。</li>
<li>125微秒 – <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%B5%E8%AF%9D">电话</a>声音的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%87%87%E6%A0%B7">采样</a>间隔。（8<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/KHz">KHz</a>）</li>
</ul>
<h2 id="毫秒（ms）：10-3秒-编辑"><a href="#毫秒（ms）：10-3秒-编辑" class="headerlink" title="毫秒（ms）：10-3秒[编辑]"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AF%AB%E7%A7%92">毫秒</a>（ms）：10-3秒[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%95%B0%E9%87%8F%E7%BA%A7_(%E6%97%B6%E9%97%B4)&action=edit&section=9">编辑</a>]</h2><p>1毫秒(millisecond)即1000微秒。</p>
<ul>
<li>1毫秒 – 大部分电脑计算时间的基本单位。许多程式计算<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BB%B6%E9%81%B2">延迟</a>的基本单位。</li>
<li>2.4毫秒 – <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%8E%B6">鿔元素</a>的半衰期。</li>
<li>3毫秒 – <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%92%BC%E8%A0%85">苍蝇</a> 搧一次<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BF%85%E8%86%80">翅膀</a>的时间。</li>
<li>5毫秒 – <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%9C%9C%E8%9C%82">蜜蜂</a> 搧一次<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BF%85%E8%86%80">翅膀</a>的时间。</li>
</ul>
<h2 id="秒（s）-编辑"><a href="#秒（s）-编辑" class="headerlink" title="秒（s）[编辑]"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A7%92">秒</a>（s）[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%95%B0%E9%87%8F%E7%BA%A7_(%E6%97%B6%E9%97%B4)&action=edit&section=10">编辑</a>]</h2><p>国际单位制中时间的基本单位，本页面的单位基准。1秒即1000毫秒。</p>
<p>一般很少使用比秒更大的字头单位（如千秒等），而用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B0%8F%E6%97%B6">小时</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%97%A5">日</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B9%B4">年</a> 等。</p>
<ul>
<li>60秒 – 1<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%88%86%E9%92%9F">分钟</a>的长度。</li>
</ul>
<h4 id="延时-Latency-是一个常见的性能指标-在性能测试中起着非常重要的作用。"><a href="#延时-Latency-是一个常见的性能指标-在性能测试中起着非常重要的作用。" class="headerlink" title="延时(Latency)是一个常见的性能指标,在性能测试中起着非常重要的作用。"></a>延时(Latency)是一个常见的性能指标,在性能测试中起着非常重要的作用。</h4><p>简单来说,延时是指系统处理一个请求或者完成一个操作所花费的时间。它反映了系统的响应快慢。常见的延时指标有:</p>
<ul>
<li><p>网络延时:数据从发送端传到接收端所花费的时间。反映了网络的传输速度。</p>
</li>
<li><p>服务延时:服务端处理一个请求并返回响应结果所花费的时间。反映了服务的响应效率。</p>
</li>
<li><p>事务延时:用户发起一个业务操作直到得到结果所花费的时间。反映了整个业务流程的执行效率。</p>
</li>
</ul>
<p>影响延时的因素有:网络带宽、系统架构、代码优化、服务器性能等。延时过高会严重影响用户体验。</p>
<p>在性能测试中,关注延时指标可以帮助我们:</p>
<ul>
<li><p>定位系统瓶颈,发现性能问题所在。</p>
</li>
<li><p>对比不同配置下的延时曲线,找出最优方案。 </p>
</li>
<li><p>设置延时阈值,避免响应过慢影响业务。</p>
</li>
<li><p>模拟不同并发用户下的延时情况。</p>
</li>
</ul>
<p>通过延时分析,可以持续优化系统性能,提升用户体验,这是每一个资深性能测试工程师必备的专业技能。</p>
<h4 id="每秒发生的IO次数-IOPS-是评测存储系统性能的一个重要指标。"><a href="#每秒发生的IO次数-IOPS-是评测存储系统性能的一个重要指标。" class="headerlink" title="每秒发生的IO次数(IOPS)是评测存储系统性能的一个重要指标。"></a>每秒发生的IO次数(IOPS)是评测存储系统性能的一个重要指标。</h4><p>IOPS表示在一秒内系统能够执行的输入输出(Input/Output)操作总次数。输入输出操作包括读取和写入操作。</p>
<p>一般来说,IOPS值越高,说明存储系统能够处理的IO请求越多,性能也就越好。</p>
<p>影响IOPS的因素有:</p>
<ul>
<li>硬盘转速,如普通硬盘转速较慢,固态硬盘转速更快</li>
<li>随机或顺序读取写入,随机IO性能较差</li>
<li>队列深度,请求越多,等待处理的队列越长</li>
<li>读取写入比例,读写比例不均衡也会降低IOPS</li>
</ul>
<p>IOPS常见的应用场景:</p>
<ul>
<li>评估存储系统能力,是否满足业务需求</li>
<li>对比不同存储配置的性价比</li>
<li>定位存储性能瓶颈</li>
<li>监控存储性能变化趋势</li>
</ul>
<p>提高IOPS可以改善存储读写性能,提升系统整体响应速度。所以IOPS是一个非常重要的性能指标,需要关注和分析。</p>
<h2 id="TCP-Handshake"><a href="#TCP-Handshake" class="headerlink" title="TCP Handshake"></a>TCP Handshake</h2><p>![TCP Handshake](<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/Kapture">https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/Kapture</a> 2023-09-23 at 19.54.29.gif)</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/623872411.html"><span>大宋词龙——辛稼轩</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/623872411.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-09-03T15:16:28.000Z">
          2023-09-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>辛弃疾，字幼安，号稼轩居士。出生在被金国占领的宋朝领土——山东，但是抗金归宋。</p>
<p>辛弃疾是一个比苏轼更让我敬佩的词人。</p>
<p>辛弃疾这人我们大部分都是在课本上了解到他作为词人、文人的一面。我们的老师可能会讲：辛弃疾是宋朝豪放派的词人。但是仅仅一个豪放完全不能代表辛弃疾这个人。他的豪情壮志，他的勇谋双绝，他的爱国情怀都是无法简单用“豪放”二字能概括的。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/历史-过去未来/">历史,过去未来</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/429901474.html"><span>我们都应该读读《生活与命运》</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/429901474.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-09-02T14:04:18.000Z">
          2023-09-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/S6vUVUj30LkPP7OiaiauwLZtkpbIgwwWo749cshxQwNer57bhYQR1wLaeyuKYzl3nGHABzBQq6fL9w0uFHH0z9uA/640?wx_fmt=png" alt="img"></p>
<p>这本书刚到，我一动不动看了200页。眼珠子都快看瞎了还是舍不得合上它。</p>
<p>书里梁文道的序：1961年2月14日上午，苏联国家安全委员会的特务闯进来格罗斯曼的家，为的是“搜捕”一份书稿。结果他们不只是带走了书、相关笔记和草稿，甚至连打出这本书的打字机和碳纸都不放过，行动规格如同逮捕一个活人，只不过他们这次要逮捕的是一本书。</p>
<p>这实在是太令人印象深刻了。到底是一本什么样的作品会令当局如此的忌惮。</p>
<p>这本书我很早就听说过，没有读的原因很可笑——我看到俄罗斯那冗长奇怪变化多端的人名字就脑阔疼！</p>
<p>伟大的小说开头各有各的魅力。</p>
<p>“田野上雾气沉沉。顺着公路伸展开去的高压线上，闪烁着汽车车灯的反光。”</p>
<p>“在千百的俄罗斯农舍中，没有也不可能有两座完全一模一样的。凡是有生命的东西，都各有各的特性。”</p>
<p>书里的观点就是一个词——自由。生命在于自由。每个人都能过着自己想要的生活，而不是被迫过着被某些人设计好的生活。每个人都可以说自己想说的事，论自己想论的人，而不是脑袋里装着一个个禁词。</p>
<p>我们以前就经历过那样的日子——任何一句话都可能被揪住上纲上线的审问。我们为此受到了难以诉说的苦难。</p>
<p>现在都是21世纪了，”我“竟然不能成为“我”，“我”竟然不能有“独立”的脑袋。新时代，还是不喜欢有脑袋的人，他们有各种手段，恩威并施的将我们的脑袋拿走，把我们的脑袋换成他们的。让我们自己把自己的心拿出来，然后自己涂上属于他们的颜色。</p>
<p>读这本书的时候，我不自觉的会联想到自己。我就像一根草，虽然我有思想，但是我却是自然界最脆弱的东西。不仅仅经受不起狂风骤雨，就算是一条狗踏过来也能把我踩的头破血流甚至踩死。</p>
<p>我一直以为现在跟过去不一样了，高尚、真诚的人就应该像一颗颗闪烁的星星一样耀眼。但是我错了，现在还是跟原来一样——“真诚、善良的人都该死”。我原来一直幻想，这个世界会变的。变成那种——透明的、真诚的、鹿是鹿、马是马的时代。但是直到有一位像导师一样的人说——被折磨惨的都是读书人…..我才知道…..</p>
<p>最后，</p>
<p>这本书的腰封上竟然写着“当代的战争与和平”。这真的是太令人惊讶了。我要争取快点读完，然后再读一遍。</p>
<p>祝大家周末愉快</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/读书笔记/">读书笔记</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/2949411629.html"><span>学习 SHELL</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/2949411629.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-09-02T13:23:59.000Z">
          2023-09-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <ol>
<li>编写一个命令，它可以递归地查找文件夹中所有的HTML文件，并将它们压缩成zip文件。注意，即使文件名中包含空格，您的命令也应该能够正确执行</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.html&quot;</span> | xargs -d <span class="string">&#x27;\n&#x27;</span> -I&#123;&#125; zip html_files.zip &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写两个bash函数 <code>marco</code> 和 <code>polo</code> 执行下面的操作。 每当你执行 <code>marco</code> 时，当前的工作目录应当以某种形式保存，当执行 <code>polo</code> 时，无论现在处在什么目录下，都应当 <code>cd</code> 回到当时执行 <code>marco</code> 的目录。 为了方便debug，你可以把代码写在单独的文件 <code>marco.sh</code> 中，并通过 <code>source marco.sh</code>命令，（重新）加载函数。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存当前工作目录</span></span><br><span class="line"><span class="function"><span class="title">marco</span></span>() &#123;</span><br><span class="line">	<span class="built_in">export</span> MARCO_DIR=$(<span class="built_in">pwd</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回到 marco 保存的目录</span></span><br><span class="line"><span class="function"><span class="title">polo</span></span>() &#123;</span><br><span class="line">	<span class="built_in">cd</span> <span class="variable">$MARCO_DIR</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 1.首先运行source marco.sh,然后在当前目录运行marco</span></span><br><span class="line"><span class="comment"># 2.cd 到任意目录，运行polo,就会返回到当时执行 `marco` 的目录</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/image-20230902212716936.png" alt="image-20230902212716936"></p>
<ol start="3">
<li>编写一个命令或脚本递归的查找文件夹中最近使用的文件。更通用的做法，你可以按照最近的使用时间列出文件吗？</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span>=<span class="variable">$1</span> <span class="comment"># m-modified时间 a-访问时间</span></span><br><span class="line"></span><br><span class="line">find . -<span class="built_in">type</span> f -print0 | xargs -0 <span class="built_in">stat</span> -f <span class="string">&#x27;%$&#123;type&#125;%t%S$&#123;type&#125; %N&#x27;</span> | <span class="built_in">sort</span> -nr</span><br></pre></td></tr></table></figure>


      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/1443152254.html"><span>我有自己的想法，我该死吗？</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/1443152254.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-30T13:48:30.000Z">
          2023-08-30
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>日本宣布开始排放福岛第一核电站因为2011年核事故而产生的核污水之后，我国再一次掀起了抢盐的风潮。我印象里最早一次国民级别的抢盐大战是在“非典时期”。</p>
<p>2003年无论是卖什么的小贩，都做起了食盐生意，并且很快从抢购食盐扩展到大米、食用油、调味品。为什么要疯狂的囤积食盐和一切与食盐有关的东西呢？</p>
<p>答案是当年的“非典型肺炎”让民众误以为是与“加碘盐”有关系。因此才疯狂的抢购。</p>
<p>那如今都2023年了，为什么还要抢盐呢？答案就是下面这幅图</p>
<p><img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/image-20230830221438327.png" alt="image-20230830221438327"></p>
<p>不知道是从哪儿流传出来的；碘片可以预防核辐射。</p>
<p>那么真相究竟是什么呢？</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/一个人/">一个人</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/1115468404.html"><span>Java CompletableFuture Demo</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/1115468404.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-28T11:56:18.000Z">
          2023-08-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h2><p>When working with asynchronous operations with Java,the CompletableFuture class offers a way to manage these operations in a more intuitive and structured manner.Two commonly used methods in this class for handling multiple asynchronous tasks are <code>allOf()</code>and <code>join()</code>.In the artcle,we will study these two methods.</p>
<h2 id="2-Combining-Multiple-CompletableFuture"><a href="#2-Combining-Multiple-CompletableFuture" class="headerlink" title="2.Combining Multiple CompletableFuture"></a>2.Combining Multiple CompletableFuture</h2><h3 id="2-1-Useing-CompletableFuture-allOf-join"><a href="#2-1-Useing-CompletableFuture-allOf-join" class="headerlink" title="2.1 Useing CompletableFuture.allOf().join()"></a>2.1 Useing CompletableFuture.allOf().join()</h3><p>The <code>allOf()</code>methods in CompletableFuture allows you to combine multiple asynchronous tasks and create a new CompletableFuture that completes when all of the input futures are completed.The <code>join()</code> methods is then used to block the current thread until all the input futures are completed.This is particularly useful when you have a collection of tasks that need to executed concurrently,and you want to wait for all of then to complete before proceeding.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">allOfDemo</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//是用CompletableFuture的allOf方法实现一个例子</span></span><br><span class="line">  CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="number">5</span>);</span><br><span class="line">  CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="number">10</span>);</span><br><span class="line">  <span class="comment">//join方法用来阻塞当前线程，等待future1 future2 计算完成</span></span><br><span class="line">  CompletableFuture.allOf(future1, future2).join();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> future1.get();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> future2.get();</span><br><span class="line">    System.out.println(<span class="string">&quot;result1: &quot;</span> + (integer));</span><br><span class="line">    System.out.println(<span class="string">&quot;result2: &quot;</span> + (integer1));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-Useing-CompletableFuture-allOf-join-with-multithreading"><a href="#2-2-Useing-CompletableFuture-allOf-join-with-multithreading" class="headerlink" title="2.2 Useing CompletableFuture.allOf().join() with multithreading"></a>2.2 Useing CompletableFuture.allOf().join() with multithreading</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">allDemoThread</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">ExecutorService</span> <span class="variable">executor1</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">  <span class="type">ExecutorService</span> <span class="variable">executor2</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">  CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">3000</span>); <span class="comment">// 休眠3秒</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">  &#125;, executor1);</span><br><span class="line"></span><br><span class="line">  CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">3000</span>); <span class="comment">// 休眠3秒</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;, executor2);</span><br><span class="line"></span><br><span class="line">  CompletableFuture.allOf(future1, future2).join();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> future1.get();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> future2.get();</span><br><span class="line">    System.out.println(<span class="string">&quot;result1: &quot;</span> + (integer));</span><br><span class="line">    System.out.println(<span class="string">&quot;result2: &quot;</span> + (integer1));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    executor1.shutdown();</span><br><span class="line">    executor2.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-Using-CompletableFuture-join"><a href="#2-3-Using-CompletableFuture-join" class="headerlink" title="2.3 Using CompletableFuture.join()"></a>2.3 Using CompletableFuture.join()</h2><p>On the other hand, the <code>join()</code> method on a single <code>CompletableFuture</code> is used to block the current thread and retrieve the result when the future is completed. This is useful when you have a single task that you want to wait for and obtain the result from. It’s important to note that unlike <code>allOf()</code>, <code>join()</code> is not used for combining multiple futures but for waiting on a single future.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="number">42</span>);</span><br><span class="line">   <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> future.join();</span><br><span class="line">   System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a>Error Handling</h2><h3 id="3-1-Handling-Exceptions-in-CompletableFuture-allOf-join"><a href="#3-1-Handling-Exceptions-in-CompletableFuture-allOf-join" class="headerlink" title="3.1 Handling Exceptions in CompletableFuture.allOf().join()"></a>3.1 Handling Exceptions in CompletableFuture.allOf().join()</h3><p>When using <code>CompletableFuture.allOf().join()</code>, exceptions that occur in any of the input futures are not directly propagated to the calling thread. Instead, the exceptions are typically stored within the individual futures. To handle exceptions in this scenario, you’ll need to retrieve them from the completed futures.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">AllOfErrorHandlerDemo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//处理CompletableFuture.allOf().join()中的异常,使用CompletableFuture.allOf().join()方法等待所有的CompletableFuture完成</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="number">5</span>)</span><br><span class="line">                .exceptionally(ex -&gt; &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;Exception in future1: &quot;</span> + ex);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Default value or recovery logic</span></span><br><span class="line">                &#125;);</span><br><span class="line">        CompletableFuture&lt;Object&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Something went wrong&quot;</span>);</span><br><span class="line">        &#125;).exceptionally(ex -&gt; &#123;</span><br><span class="line">            <span class="comment">//异常处理</span></span><br><span class="line">            System.err.println(<span class="string">&quot;Exception in future2: &quot;</span> + ex);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 返回一个新的CompletableFuture，当所有的CompletableFuture都完成后，新的CompletableFuture完成</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; combinedFuture = CompletableFuture.allOf(future1, future2);</span><br><span class="line">        <span class="comment">// join()方法等待future1和future2完成，然后打印结果</span></span><br><span class="line">        combinedFuture.join();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result1</span> <span class="operator">=</span> future1.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> (<span class="type">int</span>) future2.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;Result 1: &quot;</span> + result1);</span><br><span class="line">            System.out.println(<span class="string">&quot;Result 2: &quot;</span> + result2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>In this example, we’re using the <code>.exceptionally()</code> method to handle exceptions for each individual future. This allows us to log the exception and provide a default value or recovery logic if needed.</p>
<h2 id="4-Conclusion"><a href="#4-Conclusion" class="headerlink" title="4 Conclusion"></a>4 Conclusion</h2><p>In conclusion,both <code>CompletableFuture.allOf().join()</code> and <code>CompletableFuture.join()</code> are valuable tools in the asynchronous programming toolkit. They serve different purposes: <code>allOf().join()</code> is for combining multiple futures and waiting for their completion, while <code>join()</code> is for waiting on a single future. Understanding their use cases, behavior, and performance implications can greatly enhance your ability to write efficient and responsive asynchronous code in Java.</p>
<p>Java CompletableFuture Demo</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Java/">Java</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/4133792178.html"><span>RSA加密算法中的公钥和密钥</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/4133792178.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-26T15:38:31.000Z">
          2023-08-26
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="密钥对"><a href="#密钥对" class="headerlink" title="密钥对"></a>密钥对</h2><p>在昨天的文章<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/gItGxsGYi0SH5h237awSS">RSA加密算法</a>中提到了两个关键词——公钥、私钥。并且我们知道了，RSA 的加密就是求“明文的E次方 mod N”，解密是求“密文的D次方 mod N”。那么公式中的E、D、N这三个数就是<strong>生成的密钥对</strong>。</p>
<p>这三个数字肯定不是随随便便就拿来用的，那样的话加密也太容易被破解了。它们有自己的生成方式。</p>
<h2 id="RSA密钥对的生成"><a href="#RSA密钥对的生成" class="headerlink" title="RSA密钥对的生成"></a>RSA密钥对的生成</h2><p>我们先来简单陈述一下RSA密钥对的生成步骤，这其中涉及到了一些数学原理，暂时先不用知道什么意思。因为我也一知半解</p>
<ol>
<li>选择两个大的随机的质数 p 和 q</li>
<li>p 和 q进行乘法运算得到的值就是 N，这个N 就是公钥和私钥mod的那个N</li>
<li>计算 φ(n)， φ(n)= (p-1)*(q-1),其中φ是<strong>欧拉函数</strong>。暂时先不用知道什么是欧拉函数</li>
<li>现在来计算E，E 的计算规则是大于1但是小于 φ(n) 并且与 φ(n)<strong>互为质数</strong>。这个E就是公钥中的次幂数，暂时先不用知道什么是质数</li>
<li>现在来计算D，我们现在已经计算出来了公钥，E 和 N，那么D的计算规则需要满足以下条件：**(E * D) % φ(N) = 1**。为什么非要满足这个公式呢？因为只要数字D满足上述条件，通过E 和 N 进行加密的数据就可以通过D 和 N 进行解密</li>
</ol>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/密码技术-读书笔记/">密码技术,读书笔记</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/1463216031.html"><span>图解密码技术——RSA 公钥密码算法</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/1463216031.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-20T12:57:46.000Z">
          2023-08-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="公钥密码"><a href="#公钥密码" class="headerlink" title="公钥密码"></a>公钥密码</h2><p>公钥密码（Public-key cryptography）也称为非对称密码。是一种基于密钥对的密码体制。他需要两个密钥：公开密钥（public key ）和私有密钥（private key）。一般使用公钥加密，私钥解密。</p>
<h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><h3 id="什么是-RSA-？"><a href="#什么是-RSA-？" class="headerlink" title="什么是 RSA ？"></a>什么是 RSA ？</h3><p>RSA 是一种公钥密码算法，是目前使用最广泛的公钥密码算法。RSA 三个字母的含义是：它的三位发明者的姓氏首字母——</p>
<p>Ron Rivest、Adi Shamir 和 Leonard Adleman（Rivest Shamir Adleman）。</p>
<blockquote>
<p>在详细介绍 RSA 之前，需要先普及一点数学知识。</p>
</blockquote>
<h3 id="取模（余数）"><a href="#取模（余数）" class="headerlink" title="取模（余数）"></a>取模（余数）</h3><p>我们知道在编程语言中有<strong>取模运算</strong>，取模运算就是求余数的运算。例如：</p>
<p>我们要计算 12 除以 5 的余数，运算过程为：</p>
<ol>
<li> 12  中有几个 5？答案是 2 个。因为 5 * 2 = 10, 5 * 3 = 15 。所以 12  中只包含 2 个 5</li>
<li>那么两个 5 相乘不够 12 ，还差多少呢？12 - 10  = 2，这个 2 就是余数。</li>
<li>那么上述过程用Java 编程语言表示就是：<code>System.out.println(12 % 5); </code></li>
<li>这是简单的取模运算，那么我在来搞的复杂一点，12  这个数字可以分解为 2 * 2 * 2 * 2，也就是 2<sup>4</sup></li>
<li>我们来写一次取模的运算 2<sup>4</sup> mod 5</li>
</ol>
<p>我们简单回顾了十几二十年前的知识，如果你理解了上面的过程那么你就已经为详细学习 RSA 打好了基础，<strong>因为 RSA 的加密解密过程所进行的就是上述运算</strong></p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/密码技术-读书笔记/">密码技术,读书笔记</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/330343654.html"><span>《美国四百年》——师夷长技</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/330343654.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-20T12:26:00.000Z">
          2023-08-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>首先夸一下理想国。书本的装帧设计和印刷质量是真的好，捧在手里是真的有质感。</p>
<hr>
<p>之前一段时间看了一点《<a target="_blank" rel="noopener" href="https://www.books.com.tw/products/0010960415">獨立宣言：一部全球史</a>》。书里介绍，从全球的视角从新审视独立宣言，举世闻名的《独立宣言》不仅仅是美国的立国文书，更为现代世界的文明立下了文明的基础。对世界各地造成了巨大的影响。如今在看这本《美国四百年》更是感触颇深。美国是世界上最强大，最文明的国家之一。美国的《独立宣言》更是被视为国家财富，宣言中的人生而平等、人被赋予了生命权、自由权和追求幸福的权利….每一个字都透着美国特有的光彩。</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/读书笔记/">读书笔记</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2023 Liberte
    
  </p>
本站总访问量<span id="busuanzi_value_site_pv"></span>次
</footer>
    
    
  </div>
</div>
</body>
</html>