<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Liberte blog</title>

  
  <meta name="author" content="Liberte">
  

  

  
  <meta name="keywords" content="Java,Spring,Notes">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Liberte blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Liberte blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Liberte blog</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/search">搜索</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/blog/3017106146.html"><span>代理模式-静态代理</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/3017106146.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-05-29T15:04:35.000Z">
          2023-05-29
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="代理模式简述"><a href="#代理模式简述" class="headerlink" title="代理模式简述"></a>代理模式简述</h2><p><strong>代理模式</strong>（Proxy Pattern）是程序设计中的一种设计模式。</p>
<p>所谓的代理可以简单理解为是一个<strong>中介</strong>。举一个生活中常见的例子：假如小王需要请刘德华唱歌，但是小王自己联系不到刘德华本人，小王只能联系他的经纪人，那么这个经纪人就是刘德华的代理。</p>
<blockquote>
<p>在编程世界中，这个[代理者]就是一个<strong>类</strong>。这个类可以作为其它行为的接口。</p>
</blockquote>
<p>代理模式的[统一建模语言(UML)</p>
<p><img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/2880px-Proxy_pattern_diagram.svg.png" alt="[统一建模语言(UML)](https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/2880px-Proxy_pattern_diagram.svg-20230529230514395.png)图"></p>
<h2 id="代理的分类"><a href="#代理的分类" class="headerlink" title="代理的分类"></a>代理的分类</h2><h3 id="什么是静态代理"><a href="#什么是静态代理" class="headerlink" title="什么是静态代理"></a>什么是静态代理</h3><p>静态代理是代理模式的一种实现方式，它具有以下几个特点：</p>
<ol>
<li>目标对象和代理对象实现的是同一个业务接口。UML 图中的 Proxy 类就是代理对象， RealSubject 类就是目标对象</li>
<li>目标对象必须实现接口。UML 图中的 Proxy 实现了接口 Subject</li>
<li>代理对象在程序的运行之前已经存在</li>
<li>能够做到对目标对象的灵活切换，但是无法完成功能的灵活切换</li>
</ol>
<h4 id="业务实现"><a href="#业务实现" class="headerlink" title="业务实现"></a>业务实现</h4><p>唱歌。小王需要请刘德华唱歌，刘德华就是目标对象。</p>
<p>经纪人。经纪人就是代理对象。这个经纪人既可以跟小王对接，也可以跟车的刘德华对接。</p>
<p>小王，就是所谓的客户端。UML 中的 Client。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ol>
<li>定义买车的业务接口 Service</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">buyCar</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>目标对象 LiuDeHua</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">buyCar</span><span class="params">()</span>&#123;</span><br><span class="line">  Sout(<span class="string">&quot;我正在唱歌&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>定义代理对象Agent并实现与目标对象一样的接口；并实现买车动作前后需要完成的动作</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">buyCar</span><span class="params">()</span>&#123;</span><br><span class="line">  Sout(<span class="string">&quot;谈价钱&quot;</span>);</span><br><span class="line">  <span class="comment">//买车的动作，需要目标对象自己完成</span></span><br><span class="line">  <span class="type">LiuDeHua</span> <span class="variable">liudehua</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiuDeHua</span>();</span><br><span class="line">  liudehua.buyCat();</span><br><span class="line">  Sout(<span class="string">&quot;唱完歌，结账&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>测试</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">//new 出来代理类</span></span><br><span class="line">  <span class="type">Agent</span> <span class="variable">agent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Agent</span>();</span><br><span class="line">  agent.sing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>琢磨下：上述例子中，我们只能代理刘德华，那如果来了陈奕迅我们应该怎么办呢？</p>
<h2 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h2><p><strong>类中的成员变量设计为接口，方法的形参设计为接口，方法的返回值设计为接口，调用时接口指向实现类</strong></p>
<p>首先，在上面的例子中，我们的代理类 Agent在自己的类中new了一个 LiuDeHua的实例，然后完成了唱歌前的定价动作和唱歌后的结账动作。那么，这时候我们只能听到刘德华唱的歌。那如果我们现在想要听陈奕迅的歌，应该怎么办呢？难道在 Agent 中在 new 一个 ChenYiXun 的实例吗？我们的代理类（经纪人）每次只能代理一个实例（明星）啊。这时候，我们就要采用<strong>面向接口编程</strong>的方式了。</p>
<ol>
<li>我们已经知道有一个接口 Service中有 sing()方法。那么接下来我们将Service 作为Agent 类的成员变量</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agent</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类中的成员变量设计为接口</span></span><br><span class="line">    <span class="keyword">public</span> Service target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>我们实现一个带有参数的构造方法：将 Service 作为参数传进去</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agent</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类中的成员变量设计为接口</span></span><br><span class="line">    <span class="keyword">public</span> Service target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入目标对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Agent</span><span class="params">(Service target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>最后，我们将调用的方法，由直接 new 实现类改为接口指向</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agent</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类中的成员变量设计为接口</span></span><br><span class="line">    <span class="keyword">public</span> Service target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入目标对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Agent</span><span class="params">(Service target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;谈价钱....&quot;</span>);</span><br><span class="line">        <span class="comment">//业务功能必须使用目标对象</span></span><br><span class="line">        <span class="comment">//面向接口编程，调用时，接口指向实现类；target就是传进来的实现类，刘德华或者陈奕迅等等....</span></span><br><span class="line">        target.sing();</span><br><span class="line">        System.out.println(<span class="string">&quot;唱完结账.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyTest 类中的代码：</p>
<ol>
<li>第一版；此时 new Agent()调用的是无参构造</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Agent</span> <span class="variable">agent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Agent</span>();</span><br><span class="line">  agent.sing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>第二版；new Agent(Service target)调用的是参数为 Service 接口的有参构造；此时，会调用 Agent 的有参构造方法</li>
</ol>
<p><code>public Agent(Service target) &#123;this.target = target;&#125;</code></p>
<p>此时做到了接口指向实现类的动作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Agent</span> <span class="variable">agent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Agent</span>(<span class="keyword">new</span> <span class="title class_">ChenYiXun</span>());</span><br><span class="line">  agent.sing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们实现了一个简单的静态代理，简单了解了面向接口编程的思想。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/设计模式，静态代理，Java/">设计模式，静态代理，Java</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/402495650.html"><span>爱，至关重要</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/402495650.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-05-28T12:26:38.000Z">
          2023-05-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="自律"><a href="#自律" class="headerlink" title="自律"></a>自律</h2>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/爱，自律，为人父母/">爱，自律，为人父母</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/1445407464.html"><span>wireshark 学习笔记（一）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/1445407464.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-05-28T06:14:04.000Z">
          2023-05-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/187293033.html"><span>大扫除</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/187293033.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-05-28T06:13:39.000Z">
          2023-05-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/4218087443.html"><span>关于腰间盘突出</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/4218087443.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-05-13T01:28:50.000Z">
          2023-05-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="什么是椎间盘突出"><a href="#什么是椎间盘突出" class="headerlink" title="什么是椎间盘突出"></a>什么是椎间盘突出</h2><p>我们脊柱是由一堆称之为椎骨的骨头一个一个叠起来构成的。这些叠起来的骨头之间有一些起到缓冲作用的具有弹性的椎间盘。弹性椎间盘有一个比较柔软的类似果冻的中心或者髓核，这个“果冻”被坚韧的具有弹性的外壳包裹。如果这些弹性的椎间盘的外部出现撕裂，柔软的内部会滑溜出来，这就会导致椎间盘突出，也被称之为椎间盘滑出或者椎间盘撕裂。这种椎间盘损伤可能会刺激附近的神经，从而导致手臂或腿部疼痛、麻木或无力。</p>
<p><img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/mcdc7_herniated_disk-8col.jpg" alt="mcdc7_herniated_disk-8col"></p>
<h2 id="椎间盘突出的成因"><a href="#椎间盘突出的成因" class="headerlink" title="椎间盘突出的成因"></a>椎间盘突出的成因</h2><p>我们大部分时候都不知道到底是什么原因导致的椎间盘突出。但是，随着年龄的增加，椎间盘出现增龄性磨损，也就是椎间盘老化退变所致。椎间盘的柔韧性降低，增加了撕裂的风险。</p>
<p>我们平时工作中生活中，干重活或者搬东西的时候错误的利用了背部的肌肉而不是腿部的肌肉极易引起椎间盘突出，也可能是我们工作了一上午，背部僵硬但是却盲目笨拙的扭转导致。</p>
<p>导致椎间盘突出的原因有很多，除了年龄原因还有其他多种因素会增加椎间盘滑出的危险。体重过大会大大增加对下背部椎间盘的压力。有些人也可能存在遗传性的椎间盘破裂倾向。长期从事体力劳动和吸烟可能会减少椎间盘之间的氧气供应，导致椎间盘退变加快。</p>
<p>总结一下成因</p>
<ul>
<li><strong>体重</strong>。过于肥胖会导致下背部的压力成倍增加，这样会给下背部的椎间盘带来额为的压力</li>
<li><strong>职业</strong>。长期从事体力劳动也会增加椎间盘的压力。反复的提、拉、搬、扭腰也可能会增加椎间盘撕裂的风险</li>
<li><strong>遗传</strong>。有些人会有遗传性的椎间盘突出</li>
<li><strong>抽烟</strong>。长期抽烟，会导致椎间盘之间的氧气供应，会导致椎间盘更快的退化</li>
<li><strong>开车，久坐</strong>。司机、程序员、等久坐的职业会增加椎间盘突出的患病风险</li>
</ul>
<h2 id="椎间盘突出的症状"><a href="#椎间盘突出的症状" class="headerlink" title="椎间盘突出的症状"></a>椎间盘突出的症状</h2><p>大部分人椎间盘突出可能没有任何症状。在椎间盘初期，我们通常是不会感受到因椎间盘突出而导致的不适。</p>
<p>一般情况下，椎间盘突出的典型症状包括：剧痛或者刺痛的手臂或者腿部疼痛，还包括屁股、大腿、小腿一直到脚部的疼痛或者刺痛以及麻木。具体的症状取决于椎间盘突出的位置以及是否压迫到周围神经。</p>
<p>总结一下症状</p>
<ul>
<li><strong>手臂痛或者腿痛</strong>。通常情况下如果您的下背部出现椎间盘突出，除了下背部疼痛之外，还会感觉到屁股、大腿小腿的疼痛或者麻木，严重的时候也会感觉得到脚部疼痛和麻木。如果椎间盘出现在颈椎部位的话，通常产生手臂疼痛肩部疼痛。咳嗽或者打喷嚏的时候疼痛感会迅速传入手臂或者腿部，这种痛感一般为刺痛或者灼烧感的疼痛</li>
<li><strong>麻木痛或者麻刺痛</strong>。椎间盘突出的患者如果出现神经被压迫则会出现侧身体放射性麻木或者麻刺感</li>
<li><strong>虚弱无力</strong>。椎间盘压迫神经还会出现肌肉无力，使不上劲儿感到虚弱等。</li>
</ul>
<h2 id="预防措施"><a href="#预防措施" class="headerlink" title="预防措施"></a>预防措施</h2><ol>
<li><p>一般来说我们建议慢跑或者悬垂的运动方式来预防椎间盘突出。散步、慢跑、平板支撑、臀桥等运动可以强化我们的躯干肌肉来为我们的脊柱提供更多的支撑力。</p>
<p><img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/ds00893_im03621_fsm7_corebridgethu_jpg.png" alt="ds00893_im03621_fsm7_corebridgethu_jpg"></p>
</li>
<li><p>保持良好的坐姿，我们建议尤其是久坐的工作职业，应该保持良好的坐姿，保持背部的挺直。正确的搬举重物，运用我们腿部的肌肉减少背部发力。</p>
</li>
<li><p>最好戒烟。</p>
</li>
</ol>
<p>祝大家身体健康</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/健康-一知半解/">健康,一知半解</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/blog/2432194193.html"><span>Java程序中出现大量CPU消耗问题的排查</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/2432194193.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-05-10T13:42:47.240Z">
          2023-05-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>项目中可能会出现消耗大量 CPU 的情况(如下图)，当我们发现这种情况应该怎么排查呢？</p>
<p><img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/image-20230521232200245.png" alt="image-20230521232200245"></p>
<h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>首先使用<code>top</code>命令查看所有运行的进程占用资源的情况。可以看到上图中PID为14646的Java进程的CPU使用率达到了799.6%，这明显是有问题的。那我们应该怎么定位那一段代码出问题了呢？</p>
<h2 id="jstack-p-pid"><a href="#jstack-p-pid" class="headerlink" title="jstack -p pid"></a>jstack -p pid</h2><p>使用 <code>top</code>命令可以得到进程的PID，上述Java程序的PID是14646，我们运行JDK自带的命令<code>jstack</code>命令 dump 正在运行的Java进程堆栈。（如下图）</p>
<p><img src="https://raw.githubusercontent.com/onlywyt/wyt-pic/main/img/image-20230521230107816.png" alt="image-20230521230107816"></p>
<p>我们根据<code>top</code>命令看到的线程的id（十进制）转为 十六进制，然后在上图中找到对应的堆栈，然后根据堆栈找到代码中的行号。</p>
<p>这个简单的例子演示了<code>jstack -p pid </code>的使用方法以及生产环境中排查死锁、死循环等问题。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
</nav>
    </main>

    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2023 Liberte
    
  </p>
本站总访问量<span id="busuanzi_value_site_pv"></span>次
</footer>
    
    
  </div>
</div>
</body>
</html>